# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/csg_50_usage_copules.ipynb (unless otherwise specified).

__all__ = [
    "config",
    "calcul_distrib_from_copules",
    "individus_to_foyer_fiscaux",
    "foyer_fiscaux_to_individus",
    "convert_erfr_to_openfisca",
    "liste_des_variables_csg",
    "get_aggregate",
    "get_ratios",
    "convert_to_openfisca",
]

# Cell
import random

import pandas as pd

from .config import load_config

config = load_config()

# Cell


def calcul_distrib_from_copules(value_ref, dict_copules):
    """
    Implementation d'une fonction probabilistique qui associe une valeur estimée pour une variable VAR selon       la valeur d'une variable de référence VAR_REF , en utilisant des copules calculés à partir des                 distributions de VAR1 et VAR_REF.
    Par exemple, VAR1 = Rk et VAR_REF = RFR

    Dans quel bucket est value_ref ? ===> Nous donne la distrib de VAR
    value_ref :  une valeur de VAR_REF pour laquelle on cherche à attribuer une valeur de VAR
    dictionnaire_fichier
    """

    for bucket in dict_copules:
        if bucket["lower_bound"] <= value_ref < bucket["upper_bound"]:
            break

    probazero = bucket["nb_people"]["zero"] / sum(bucket["nb_people"].values())

    # On genere une variable aleatoire entre 0 et 1
    randunif = random.random()
    # Si cette proba est <= à la probabilité que Rk = 0
    if randunif <= probazero:
        return 0
    # Si on n'est pas dans ce cas
    randunif = (randunif - probazero) / (1 - probazero)

    randinnbgens = randunif * bucket["nb_people"]["nonzero"]

    # Générer un rk à partir de cette distrib (Monte-Carlo probablement)
    sommepass = 0  # nombre de gens dans les buckets déjà dépassés. Quand on a passé le nombre de gens qu'on veut, on a fini de générer !
    for bucket_rk in bucket["nonzerobuckets"]:
        sommepass += bucket_rk[0]
        if sommepass > randinnbgens:
            return bucket_rk[1] / bucket_rk[0]


# Cell
def individus_to_foyer_fiscaux(sample_individus):
    """
    Regroupe un échantillon par individus en échantillon par foyers fiscaux
    """
    # On regroupe les individus de sample_pop_individus en foyers fiscaux par leur idfoy
    sample_foyers_fiscaux = sample_individus.groupby(
        ["idfoy", "wprm"], as_index=False
    ).sum()

    return sample_foyers_fiscaux


# Cell
def foyer_fiscaux_to_individus(
    sample_ind_origin, sample_ff_to_merge, cols_declarant_principal
):
    """
    Ajoute les données d'un échantillon de foyers fiscaux dans un échantillon par individus
    """
    # On fusionne les nouvelles valeurs dans l'échantillon originel par individus
    sample_individus_new = pd.merge(
        sample_ind_origin,
        sample_ff_to_merge,
        left_on="idfoy",
        right_on="idfoy",
        indicator=False,
    )

    # On supprime les valeurs qui ne s'appliquent qu'au déclarant principal pour les autres déclarants
    for col in cols_declarant_principal:
        sample_individus_new.loc[sample_individus_new["quifoy"] != 0, col] = 0

    return sample_individus_new


# Cell
def convert_erfr_to_openfisca(data):
    # Traduction des roles attribués au format openfisca
    data["quimenof"] = "enfant"
    data.loc[data["quifoy"] == 1, "quimenof"] = "conjoint"
    data.loc[data["quifoy"] == 0, "quimenof"] = "personne_de_reference"

    data["quifoyof"] = "personne_a_charge"
    data.loc[data["quifoy"] == 1, "quifoyof"] = "conjoint"
    data.loc[data["quifoy"] == 0, "quifoyof"] = "declarant_principal"

    data["quifamof"] = "enfant"
    data.loc[data["quifam"] == 1, "quifamof"] = "conjoint"
    data.loc[data["quifam"] == 0, "quifamof"] = "demandeur"
    return data


# Cell
liste_des_variables_csg = pd.read_csv(
    config["DATA_IN"] + "liste_des_variables_csg-POTE_2019.csv"
)
pd.options.display.float_format = "{:,.7f}".format
liste_des_variables_csg

# Cell


def get_aggregate(df, variable_name):
    return df.loc[df["nom_variable"] == variable_name, "somme_en_euros"].iloc[0]


# Cell
def get_ratios():
    pote_rev_capital = (
        get_aggregate(liste_des_variables_csg, "rev_k_plvt_bareme")
        + get_aggregate(liste_des_variables_csg, "rev_k_plvt_lib")
        + get_aggregate(liste_des_variables_csg, "rev_k_plvt_forf_unik")
    )
    return {
        "ratio_revenus_capitaux_prelevement_bareme": get_aggregate(
            liste_des_variables_csg, "rev_k_plvt_bareme"
        )
        / pote_rev_capital,
        "ratio_revenus_capitaux_prelevement_liberatoire": get_aggregate(
            liste_des_variables_csg, "rev_k_plvt_lib"
        )
        / pote_rev_capital,
        "ratio_revenus_capitaux_prelevement_forfaitaire_unique_ir": get_aggregate(
            liste_des_variables_csg, "rev_k_plvt_forf_unik"
        )
        / pote_rev_capital,
    }


# Cell
def convert_to_openfisca(data):
    # On voudrait faire: dummy_data_csg['revenus_capital'] = dummy_data_final_rk['rk']
    revenus_capital = data["pote_rev_capital"]

    # Dans OpenFisca, on calcule rk ainsi: rk = revenus_capitaux_prelevement_bareme + revenus_capitaux_prelevement_liberatoire + revenus_capitaux_prelevement_forfaitaire_unique_ir
    ratios = get_ratios()
    data["revenus_capitaux_prelevement_bareme"] = (
        revenus_capital * ratios["ratio_revenus_capitaux_prelevement_bareme"]
    )
    data["revenus_capitaux_prelevement_liberatoire"] = (
        revenus_capital * ratios["ratio_revenus_capitaux_prelevement_liberatoire"]
    )
    data["revenus_capitaux_prelevement_forfaitaire_unique_ir"] = (
        revenus_capital
        * ratios["ratio_revenus_capitaux_prelevement_forfaitaire_unique_ir"]
    )
    # Rentes Viageres
    data["rente_viagere_titre_onereux_net"] = data["pote_rente_viagere"]
    # Revenu catégoriel foncier
    data["revenu_categoriel_foncier"] = data["pote_rev_categ_foncier"]
    # Plus-values
    data["assiette_csg_plus_values"] = data["pote_plus_values"]

    # On n'ajoute pas chomage_brut ni  retraite_brute car déjà présent dans ERFS_FPR
    #     data["chomage_brut"] = data[
    #         "pote_chomage"
    #     ]  # À vérifier : est-ce que c'est bien chomage brut qu'on calcule a partir de POTE ? OU : y etait-il deja avant, dans l'ERFS-FPR ?
    #     data["retraite_brute"] = data[
    #         "pote_retraite"
    #     ]  # À vérifier : est-ce que c'est bien retraite brute qu'on calcule a partir de POTE ?

    # Traduction des roles attribués au format openfisca
    data["quimenof"] = "enfant"
    data.loc[data["quifoy"] == 1, "quimenof"] = "conjoint"
    data.loc[data["quifoy"] == 0, "quimenof"] = "personne_de_reference"

    data["quifoyof"] = "personne_a_charge"
    data.loc[data["quifoy"] == 1, "quifoyof"] = "conjoint"
    data.loc[data["quifoy"] == 0, "quifoyof"] = "declarant_principal"

    data["quifamof"] = "enfant"
    data.loc[data["quifam"] == 1, "quifamof"] = "conjoint"
    data.loc[data["quifam"] == 0, "quifamof"] = "demandeur"
    return data
