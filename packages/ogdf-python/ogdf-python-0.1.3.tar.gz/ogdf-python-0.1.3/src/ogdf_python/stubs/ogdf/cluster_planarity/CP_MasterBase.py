# file stubs/ogdf/cluster_planarity/CP_MasterBase.py generated from classogdf_1_1cluster__planarity_1_1_c_p___master_base
import enum
from typing import *
from ogdf_python import ogdf, cpp
std = cpp.std
class CP_MasterBase(abacus.Master):

	class solutionState(enum.Enum):

		Undefined = enum.auto()

		CPlanar = enum.auto()

		NonCPlanar = enum.auto()

	m_solState : solutionState = ...

	globalDualBound : float = ...

	globalPrimalBound : float = ...

	m_activeRepairs : int = ...

	m_branchingGap : float = ...

	#: Pointers to the given Clustergraph and underlyingGraphare stored.
	m_C : ClusterGraph = ...

	#: stores optimization success state
	m_connectionOneEdges : List[NodePair] = ...

	#: Cut pools for connectivity and Kuratowski constraints.
	m_cutConnPool : abacus.StandardPool[abacus.Constraint,abacus.Variable] = ...

	#: Kuratowski Cuts.
	m_cutKuraPool : abacus.StandardPool[abacus.Constraint,abacus.Variable] = ...

	m_G : Graph = ...

	m_heuristicFractionalBound : float = ...

	m_heuristicLevel : int = ...

	m_inactiveVariables : List[NodePair] = ...

	m_kuratowskiBoundHigh : float = ...

	m_kuratowskiBoundLow : float = ...

	#: Time threshold for optimization.
	m_maxCpuTime : str = ...

	#: Indicates if simple max planar subgraph heuristic should be used to derive lower bound if only root cluster exists.
	m_mpHeuristic : bool = ...

	m_nCConsAdded : int = ...

	m_nHeuristicPermutationLists : int = ...

	m_nHeuristicRuns : int = ...

	m_nKConsAdded : int = ...

	m_nKuratowskiIterations : int = ...

	#: Keeps track of created variables.
	m_nKuratowskiSupportGraphs : int = ...

	m_nMaxVars : int = ...

	m_nSubdivisions : int = ...

	m_numAddVariables : int = ...

	m_repairStat : ArrayBuffer[  int ] = ...

	m_solutionGraph : GraphCopy = ...

	m_solvesLP : int = ...

	m_strongConstraintViolation : float = ...

	m_strongVariableViolation : float = ...

	m_usePerturbation : bool = ...

	#: Keeps track of variables that are currently inactive during optimization.
	m_varCreated : NodeArray[NodeArray[ bool ] ] = ...

	m_varsAdded : int = ...

	m_varsBranch : int = ...

	m_varsCut : int = ...

	m_varsInit : int = ...

	m_varsKura : int = ...

	m_varsMax : int = ...

	m_varsPotential : int = ...

	m_varsPrice : int = ...

	def __init__(self, C : ClusterGraph, heuristicLevel : int = 1, heuristicRuns : int = 2, heuristicOEdgeBound : float = 0.3, heuristicNPermLists : int = 5, kuratowskiIterations : int = 3, subdivisions : int = 10, kSupportGraphs : int = 3, kuratowskiHigh : float = 0.7, kuratowskiLow : float = 0.3, perturbation : bool = False, branchingGap : float = 0.4, time : str = "00:05:00") -> None:
		"""Construction and default values."""
		...

	def __destruct__(self) -> None:
		"""Destruction."""
		...

	def addedCConstraints(self) -> int:
		...

	def addedKConstraints(self) -> int:
		...

	def epsilon(self) -> float:
		"""Returns the objective function coefficient ofC-edges."""
		...

	def getClusterGraph(self) -> ClusterGraph:
		"""Returns a pointer to the given Clustergraph."""
		...

	def getConnectionOptimalSolutionEdges(self, edges : List[NodePair]) -> None:
		"""Returns nodePairs of connecting optimal solution edges in listedges."""
		...

	def getCutConnPool(self) -> abacus.StandardPool[abacus.Constraint,abacus.Variable]:
		"""Returns cut pool for connectivity."""
		...

	def getCutKuraPool(self) -> abacus.StandardPool[abacus.Constraint,abacus.Variable]:
		"""Returns cut pool for planarity."""
		...

	def getDualBound(self) -> float:
		...

	def getGraph(self) -> Graph:
		"""Returns a pointer to the underlyingGraph."""
		...

	def getHeuristicFractionalBound(self) -> float:
		...

	def getHeuristicLevel(self) -> int:
		...

	def getHeuristicRuns(self) -> int:
		...

	def getKBoundHigh(self) -> float:
		...

	def getKBoundLow(self) -> float:
		...

	def getKIterations(self) -> int:
		...

	def getMPHeuristic(self) -> bool:
		...

	def getNKuratowskiSupportGraphs(self) -> int:
		...

	def getNSubdivisions(self) -> int:
		...

	def getNumAddVariables(self) -> int:
		...

	def getNumInactiveVars(self) -> int:
		...

	def getPrimalBound(self) -> float:
		...

	def getStdConstraintsFileName(self) -> str:
		"""The name of the file that contains the standard, i.e., non-cut, constraints (may be deleted by ABACUS and shouldn't be stored twice)"""
		...

	def getStrongConstraintViolation(self) -> float:
		...

	def getStrongVariableViolation(self) -> float:
		...

	def heuristicLevel(self, level : int) -> None:
		...

	def intGap(self) -> float:
		"""Returns a value that allows to distinguish result values when connection edges (tiny negative cost) are added."""
		...

	def nMaxVars(self) -> int:
		"""Returns the number of variables."""
		...

	def numberOfHeuristicPermutationLists(self) -> int:
		...

	def perturbation(self) -> bool:
		...

	def setHeuristicFractionalBound(self, b : float) -> None:
		...

	def setHeuristicPermutationLists(self, n : int) -> None:
		...

	def setHeuristicRuns(self, n : int) -> None:
		...

	def setKBoundHigh(self, n : float) -> None:
		...

	def setKBoundLow(self, n : float) -> None:
		...

	def setKIterations(self, n : int) -> None:
		...

	def setMPHeuristic(self, b : bool) -> None:
		"""Switches use of lower bound heuristic."""
		...

	def setNHeuristicRuns(self, n : int) -> None:
		...

	def setNKuratowskiSupportGraphs(self, n : int) -> None:
		...

	def setNSubdivisions(self, n : int) -> None:
		...

	def setNumAddVariables(self, i : int) -> None:
		...

	def setPertubation(self, b : bool) -> None:
		...

	def setPortaFile(self, b : bool) -> None:
		"""If set to true, PORTA output is written in a file."""
		...

	def setStrongConstraintViolation(self, d : float) -> None:
		...

	def setStrongVariableViolation(self, d : float) -> None:
		...

	def setTimeLimit(self, s : str) -> None:
		...

	def solutionInducedGraph(self) -> Graph:
		"""Returns the optimal solution induced Clustergraph."""
		...

	def updateAddedCCons(self, n : int) -> None:
		...

	def updateAddedKCons(self, n : int) -> None:
		...

	def updateBestSubGraph(self, connection : List[NodePair]) -> None:
		"""Updates the "best" Subgraphm_solutionGraphfound so far and fillsconnectionwith."""
		...

	def useDefaultCutPool(self) -> bool:
		"""Returns true if default cut pool is used. Otherwise, separate connectivity and Kuratowski pools are generated and used."""
		...

	def clearActiveRepairs(self) -> None:
		...

	def createInitialVariables(self, initVars : List[CPlanarEdgeVar]) -> None:
		"""All variables that have to be present at start of optimization are created here."""
		...

	def getDoubleTime(self, act : Stopwatch) -> float:
		...

	def goodVar(self, a : node, b : node) -> bool:
		...

	def heuristicInitialLowerBound(self) -> float:
		...

	def heuristicInitialUpperBound(self) -> float:
		...

	def initializeOptimization(self) -> None:
		"""The default implementation ofinitializeOptimization()does nothing."""
		...

	def isCP(self) -> bool:
		"""Derives and returns c-planarity property either directly or indirectly from computation results."""
		...

	def terminateOptimization(self) -> None:
		"""Function that is invoked at the end of the optimization. Does nothing but output inCP_MasterBase."""
		...
