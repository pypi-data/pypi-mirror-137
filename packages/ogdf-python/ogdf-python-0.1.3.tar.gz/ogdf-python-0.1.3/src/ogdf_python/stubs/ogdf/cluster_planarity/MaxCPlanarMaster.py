# file stubs/ogdf/cluster_planarity/MaxCPlanarMaster.py generated from classogdf_1_1cluster__planarity_1_1_max_c_planar_master
import enum
from typing import *
from ogdf_python import ogdf, cpp
std = cpp.std
class MaxCPlanarMaster(abacus.Master):

	def __init__(self, C : ClusterGraph, pCost : EdgeArray[ float ], heuristicLevel : int = 1, heuristicRuns : int = 2, heuristicOEdgeBound : float = 0.3, heuristicNPermLists : int = 5, kuratowskiIterations : int = 3, subdivisions : int = 10, kSupportGraphs : int = 3, kuratowskiHigh : float = 0.7, kuratowskiLow : float = 0.3, perturbation : bool = False, branchingGap : float = 0.4, time : str = "00:20:00", dopricing : bool = True, checkCPlanar : bool = False, numAddVariables : int = 15, strongConstraintViolation : float = 0.3, strongVariableViolation : float = 0.3) -> None:
		...

	def __destruct__(self) -> None:
		"""Destruction."""
		...

	def addedCConstraints(self) -> int:
		...

	def addedKConstraints(self) -> int:
		...

	def branchingOEdgeSelectGap(self) -> float:
		...

	def epsilon(self) -> float:
		...

	def firstSub(self) -> abacus.Sub:
		"""Should return a pointer to the first subproblem of the optimization, i.e., the root node of the enumeration tree."""
		...

	def getAllOptimalSolutionEdges(self, edges : List[NodePair]) -> None:
		...

	def getCheckCPlanar(self) -> bool:
		...

	def getClusterGraph(self) -> ClusterGraph:
		...

	def getConnectionOptimalSolutionEdges(self, egdes : List[NodePair]) -> None:
		...

	def getCutConnPool(self) -> abacus.StandardPool[abacus.Constraint,abacus.Variable]:
		"""Returns cut pool for connectivity."""
		...

	def getCutKuraPool(self) -> abacus.StandardPool[abacus.Constraint,abacus.Variable]:
		"""Returns cut pool for planarity."""
		...

	def getDeletedEdges(self, edges : List[edge]) -> None:
		...

	def getDualBound(self) -> float:
		...

	def getGraph(self) -> Graph:
		...

	def getHeuristicFractionalBound(self) -> float:
		...

	def getHeuristicLevel(self) -> int:
		...

	def getHeuristicRuns(self) -> int:
		...

	def getKBoundHigh(self) -> float:
		...

	def getKBoundLow(self) -> float:
		...

	def getKIterations(self) -> int:
		...

	def getMPHeuristic(self) -> bool:
		...

	def getNKuratowskiSupportGraphs(self) -> int:
		...

	def getNSubdivisions(self) -> int:
		...

	def getNumAddVariables(self) -> int:
		...

	def getNumInactiveVars(self) -> int:
		...

	def getOriginalOptimalSolutionEdges(self, edges : List[NodePair]) -> None:
		...

	def getPrimalBound(self) -> float:
		...

	def getStdConstraintsFileName(self) -> str:
		"""The name of the file that contains the standard, i.e., non-cut, constraints (may be deleted by ABACUS and shouldn't be stored twice)"""
		...

	def getStrongConstraintViolation(self) -> float:
		...

	def getStrongVariableViolation(self) -> float:
		...

	def heuristicLevel(self, level : int) -> None:
		...

	def nMaxVars(self) -> int:
		...

	def numberOfHeuristicPermutationLists(self) -> int:
		...

	def perturbation(self) -> bool:
		...

	def setHeuristicFractionalBound(self, b : float) -> None:
		...

	def setHeuristicPermutationLists(self, n : int) -> None:
		...

	def setHeuristicRuns(self, n : int) -> None:
		...

	def setKBoundHigh(self, n : float) -> None:
		...

	def setKBoundLow(self, n : float) -> None:
		...

	def setKIterations(self, n : int) -> None:
		...

	def setMPHeuristic(self, b : bool) -> None:
		"""Switches use of lower bound heuristic."""
		...

	def setNHeuristicRuns(self, n : int) -> None:
		...

	def setNKuratowskiSupportGraphs(self, n : int) -> None:
		...

	def setNSubdivisions(self, n : int) -> None:
		...

	def setNumAddVariables(self, i : int) -> None:
		...

	def setPertubation(self, b : bool) -> None:
		...

	def setPortaFile(self, b : bool) -> None:
		"""If set to true, PORTA output is written in a file."""
		...

	def setStrongConstraintViolation(self, d : float) -> None:
		...

	def setStrongVariableViolation(self, d : float) -> None:
		...

	def solutionInducedGraph(self) -> Graph:
		...

	def updateAddedCCons(self, n : int) -> None:
		...

	def updateAddedKCons(self, n : int) -> None:
		...

	def updateBestSubGraph(self, original : List[NodePair], connection : List[NodePair], deleted : List[edge]) -> None:
		...

	def useDefaultCutPool(self) -> bool:
		"""Returns true if default cut pool is used. Otherwise, separate connectivity and Kuratowski pools are generated and used."""
		...

	def heuristicInitialLowerBound(self) -> float:
		...

	def initializeOptimization(self) -> None:
		"""The default implementation ofinitializeOptimization()does nothing."""
		...

	def terminateOptimization(self) -> None:
		"""The default implementation ofterminateOptimization()does nothing."""
		...
