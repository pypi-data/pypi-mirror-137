# file stubs/ogdf/OptimalCrossingMinimizer/Subproblem.py generated from classogdf_1_1_optimal_crossing_minimizer_1_1_subproblem
import enum
from typing import *
from ogdf_python import ogdf, cpp
std = cpp.std
class Subproblem(abacus.Sub, ogdf.Logger):

	currentIntegerCrossings : List[CrossingLocation] = ...

	currentIntegerSolution : PlanRep = ...

	currentRoundedCrossings : List[CrossingLocation] = ...

	currentRoundedSolution : PlanRep = ...

	bufferedSimplicities : SList[AbacusConstraint] = ...

	deactNonLiftCons : ArrayBuffer[abacus.PoolSlot[abacus.Constraint,abacus.Variable]  ] = ...

	duplicatedKuratowskiList : SList[KuratowskiConstraint] = ...

	generatedConVar : int = ...

	storedCurrentCrossings : bool = ...

	@overload
	def __init__(self, m : abacus.Master, father : abacus.Sub, br : abacus.BranchRule) -> None:
		...

	@overload
	def __init__(self, m : abacus.Master, conRes : float, varRes : float, nnzRes : float, relativeRes : bool, constraints : ArrayBuffer[abacus.PoolSlot[abacus.Constraint,abacus.Variable]  ] = None, variables : ArrayBuffer[abacus.PoolSlot[abacus.Variable,abacus.Constraint]  ] = None) -> None:
		...

	def __destruct__(self) -> None:
		...

	def checkKnHighKuratowskiCutsStatic(self) -> int:
		...

	def checkKnmHighKuratowskiCutsStatic(self) -> int:
		...

	def checkSimplicitiesAndPrice(self) -> int:
		...

	def deactivateNonLiftableConstraints(self, vars : ArrayBuffer[abacus.Variable]) -> None:
		...

	def duplicateKuratowskis(self, cvar : CrossingVariable, L : SList[KuratowskiConstraint]) -> None:
		...

	def feasible(self) -> bool:
		"""Must check the feasibility of a solution of the LP-relaxation."""
		...

	def generateBranchRules(self, rules : ArrayBuffer[abacus.BranchRule]) -> int:
		"""Tries to find rules for splitting the current subproblem in further subproblems."""
		...

	def generateSon(self, rule : abacus.BranchRule) -> abacus.Sub:
		"""Returns a pointer to an object of a problem specific subproblem, which is generated from the current subproblem by branching rulerule."""
		...

	def improve(self, primalValue : float) -> int:
		"""Can be redefined in order to implement primal heuristics for finding feasible solutions."""
		...

	def makeFeasible(self) -> int:
		"""The default implementation ofmakeFeasible()doesnothing."""
		...

	def pricing(self) -> int:
		"""Should generate inactive variables which do not price out correctly."""
		...

	def realizeVariable(self, cvar : CrossingVariable, val : float) -> None:
		...

	def separate(self) -> int:
		"""Must be redefined in derived classes for the generation of cutting planes."""
		...

	def separateBoyerMyrvold(self, p : optimal_crossing_minimizer.BoyerMyrvoldSeparationParams) -> int:
		...

	def separateSimple(self, p : optimal_crossing_minimizer.SimpleSeparationParams) -> int:
		...

	def solveLp(self) -> int:
		"""Solves the LP-relaxation of the subproblem."""
		...

	def callBoundHeuristic(self, integer : bool) -> OptimalCrossingMinimizer.CrossingConfiguration:
		...

	def clearDeactNonLiftCons(self) -> None:
		...

	def clearDuplicatedKuratowskiList(self) -> None:
		...

	def fathom(self, reoptimize : bool) -> None:
		"""Fathoms a node and recursively tries to fathom its father."""
		...

	def findKuratowski(self, R : Graph, K : KuratowskiSubdivision) -> None:
		...

	def generateVariable(self, e1 : edge, e1id : int, e2 : edge, e2id : int, var : OptimalCrossingMinimizer.CrossingVariable) -> float:
		...

	def master(self) -> OptimalCrossingMinimizer.Master:
		...
