# file stubs/ogdf/optimal_crossing_minimizer/MasterBase.py generated from classogdf_1_1optimal__crossing__minimizer_1_1_master_base
import enum
from typing import *
from ogdf_python import ogdf, cpp
std = cpp.std
class MasterBase(abacus.Master, ogdf.Logger):

	branchingPool : abacus.StandardPool[abacus.Constraint,abacus.Variable] = ...

	cost : EdgeArray[  int ] = ...

	expansionFactor : int = ...

	forbid : EdgeArray[ bool ] = ...

	givenGraph : Graph = ...

	hintedPool : abacus.StandardPool[abacus.Constraint,abacus.Variable] = ...

	kuratowskiPool : abacus.NonDuplPool[abacus.Constraint,abacus.Variable] = ...

	lowerbound : int = ...

	m_boundHeuristic : std.unique_ptr[CrossingMinimizationModule] = ...

	m_hintEffects : int = ...

	m_isTrivial : bool = ...

	m_knownUpperBound : int = ...

	m_maxVariables : int = ...

	m_minVariables : int = ...

	m_startHeuristic : std.unique_ptr[CrossingMinimizationModule] = ...

	m_startVariables : int = ...

	m_useCost : bool = ...

	m_usedVariables : int = ...

	m_useForbid : bool = ...

	m_useSubgraphs : bool = ...

	upperbound : int = ...

	upperBoundSource : optimal_crossing_minimizer.SolutionSource = ...

	def bipartiteZara(self, n : int, m : int) -> int:
		...

	def completeHill(self, n : int) -> int:
		...

	def MAX_PAIRS(self, e : int) -> int:
		...

	def cloneBoundHeuristic(self) -> CrossingMinimizationModule:
		...

	def cloneStartHeuristic(self) -> CrossingMinimizationModule:
		...

	def hintEffects(self) -> int:
		...

	def isOptimal(self) -> bool:
		...

	def setBoundHeuristic(self, p : CrossingMinimizationModule) -> None:
		...

	def setStartHeuristic(self, p : CrossingMinimizationModule) -> None:
		...

	def useThisUpperBound(self, knownUpperBound : int = 0) -> None:
		...

	def calcLowerBounds(self) -> None:
		...

	def calcUpperBounds(self) -> None:
		...

	def doWriteBestSolution(self) -> None:
		...

	def getCost(self, e1 : edge, e2 : edge) -> int:
		...

	def probablyUpdateLowerBound(self, lb : float) -> bool:
		...

	def probablyUpdateUpperBound(self, ub : int, ubs : optimal_crossing_minimizer.SolutionSource) -> bool:
		...

	def setDefaultSettings(self) -> None:
		...

	def useCost(self) -> bool:
		...

	def useForbid(self) -> bool:
		...

	def variableAllowed(self, e1 : edge, e2 : edge) -> bool:
		...
