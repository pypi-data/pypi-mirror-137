# Internationalization and Localization

## Translations

### Terminology

- **key** is a unique identifier used to lookup code translations in the catalog.
- **sentence** is a translation for a given key. A single key might have multiple translations.
- **catalog** is a collection of translation key/values.
- **locale** is a two letter language code (for example `de` or `fr`).
- **scope** is a translation domain grouping the translation data related to a skill or service. The **scope** is usually equals to the the service/skill name.
- **.po/.mo files** - translation files in gettext format.
- **.yaml files** - translation files in Ruby format.

### Conventions

Use two letter [ISO 639-1 codes](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) for the translation language.

Do not use any country or ISO 3166-1 codes:

- Incorrect: **~~de_DE~~**
- Incorrect: **~~deu~~**
- Incorrect: **~~ger~~**
- Correct:   **de**

### Supported Formats

`skill_sdk.i18n` module supports translations in the formats listed below:

1. Translations in [`gettext`](https://www.gnu.org/software/gettext/) format. 
2. Local translations in YAML format.
3. [RoR i18n](https://guides.rubyonrails.org/i18n.html) - compatible translations.
4. Remote translations from text service.

Formats are listed in the priority order. Translation with higher priority overrides the one loaded previously.

For example, if your skill project has translations in `locales.yaml` file and gettext translations in `locale` folder,
YAML translations will take precedence and, your skill will not load gettext files when deployed.
Later, the YAML translations may still be overridden with data from text service (if configured). 

### Loading Translations

#### Translations in `gettext` Format

Local gettext translation files are expected in the `locale/` folder. 
The loader searches first for [`<lang>.mo`](https://www.gnu.org/software/gettext/manual/html_node/MO-Files.html) (compiled translation), 
then for [`<lang>.po`](https://www.gnu.org/software/gettext/manual/html_node/PO-Files.html) files.
If no MO-files corresponding to the PO-files found, the translations will be compiled.

As an example, a skill that supports English, French and German language has the following directory structure:

```
skill-root/
└── locale/
    ├── de.po
    ├── en.po
    └── fr.po
```

#### YAML Translations

Local translations in YAML format are also loaded from `locale/` folder. 
Each file must have lower-cased ISO 3166-1 language code as a name: `<lang>.yaml`.
Translations are key-values, where every translation key must have at least one translation value (multiple values are supported):

```yaml
DELETE_ALL_ITEMS:
- Ok, deine offenen Einträge der {list_type} wurden entfernt.
- Alles klar, ich habe die offenen Einträge der {list_type} gelöscht.
```

YAML translations may have a language code as root element for compatibility with [RoR i18n](https://guides.rubyonrails.org/i18n.html).
The language code must be equal to the code specified by file name, otherwise `RuntimeError` is raised.  

For the sample above, the translations to German must be in `locale/de.yaml`:

```yaml
de:
  DELETE_ALL_ITEMS:
  - Ok, deine offenen Einträge der {list_type} wurden entfernt.
  - Alles klar, ich habe die offenen Einträge der {list_type} gelöscht.
```

#### Ruby on Rails i18n Translations

YAML translations can be combined in a single file with language codes as root elements.
By default, the translation loader will try to load them from `locales.yaml` file in skill project's root.

Example:

```yaml
en:
  DELETE_ALL_ITEMS:
  - Ok, your open entries of the {list_type} have been removed.
  - All right, I deleted the open entries of the {list_type}.

de:
  DELETE_ALL_ITEMS:
  - Ok, deine offenen Einträge der {list_type} wurden entfernt.
  - Alles klar, ich habe die offenen Einträge der {list_type} gelöscht.
```

#### Text Service

A central text service provides the translation data. An API wrapper is implemented in `skill_sdk.services.text.TextService`.

The text service is configured in `[service-text]` section of `skill.conf` file:

```ini
[service-text]
url = http://service-text-service:8080
active = [true | false]             (true)
auth_header = [false | true]        (false)
load = [auto | delayed | startup]   (auto)
```

The text services endpoint URL is set by `url` parameter. 
Default value for locally deployed skill is `http://service-text-service:8080`.

To explicitly deactivate the service, set the `active` parameter to `false`. Default value is `true`. So if you have just 
the `[service-text]` section in your skill configuration file, the service is activated during the skill deployment.

If `auth_header` value is set to `true`, bearer authentication is used when making requests to the text service:
an `Authorization: Bearer {token}` header is added to the request, 
bearer token is extracted from the skill invoke request.

The `load` parameter in `[service-text]` section defines **when** the translations are requested from text services:

    "auto":     the translations are loaded at skill startup and reloaded at TEXT_SERVICE_UPDATE_INTERVAL
                a skill will start without translations if text services are unavailable
                (this is a default behaviour)

    "delayed":  the skill will start without translations and loads the catalog when requested by CVI
                (i.e on a first invocation, if the translations are empty)

    "startup":  the translations are loaded at skill startup and reloaded at TEXT_SERVICE_UPDATE_INTERVAL
                a skill will raise a l10n.TranslationError exception if text services are not available

#### Translation Loading

When skill is being deployed, the translations are loaded in the following order:

1. Try loading translations from `locales.yaml` file.
1. Scan the projects `locale/` folder for `<lang>.yaml` files.
1. Scan the projects `locale/` folder for `<lang>.po` files, and compile `.po` files to `.mo`.
1. Request the list of supported locales for this scope from the text service.
1. Load the translations from the text service and replace the `gettext` translations.

### Usage in Code

The translation that matches the locale of the request is injected into the `context` as `translation`.

The translation supports the following methods:

- `gettext()`
- `ngettext()`
- `getalltexts()` (this method returns a list of all available texts for a specific tag and language)

>You find a description of these methods in the [gettext.GNUTranslations API docs](https://docs.python.org/3/library/gettext.html#the-gnutranslations-class).

For convenience purposes, the following shortcuts exist:

- `context._()` for `context.translation.gettext()`
- `context._n()` for `context.translation.ngettext()`
- `context._a()` for `context.translation.getalltexts()`

Global `l10n._`/`l10n._n`/`l10n._a` functions are available. They are thread-safe and if accessed within a request invocation context, 
these functions always refers to the currently requested locale.
 
#### Examples

```python
from skill_sdk.l10n import _
from skill_sdk.skill import intent_handler

@intent_handler('HELLO_INTENT')
def hello():
    return _('HELLO')
```

```python
from skill_sdk.l10n import _, _n, _a

card_title = _('WEATHER_CARD_TITLE')
text = _n('WEATHER_TEXT_ONE_DAY', 'WEATHER_TEXT_MULTIPLE_DAYS', num_days)
all_texts = _a('THANKS')
```
You can create a response message with format arguments by using a constructor or `format` function. The following two statements are equivalent:
```python
text = _('WEATHER_TEXT', temperature=temp, forecast=forecast)
text = _('WEATHER_TEXT').format(temperature=temp, forecast=forecast)
```

### Usage in Unit Tests

When you write tests or test your app with Python unit test modules, consider that during unit testing the text service does not load the actual translation. 
In this case, the translation system uses your local `gettext` translation in the `locale` folder or, if no `locale` folder is available, no translation at all.

**Example**

If you create your message by using the `format` function `text = context._('WEATHER_TEXT').format(temperature=temp, forecast=forecast)`,
the `text` variable contains additional fields:
```python
>>> type(text)
<class 'skill_sdk.l10n.Message'>
>>> text.key
'WEATHER_TEXT'
>>> text.kwargs
{'temperature': temp, 'forecast': forecast}
```

To avoid issues when a multi-locale translation is available, use the following fields in your unit test: 

```python
self.assertEqual(text.key, 'WEATHER_TEXT')
```

Alternatively, you can nullify the translations before executing the unit tests:
```python
from skill_sdk.test_helpers import set_translations
set_translations(None)   
```

This function call sets all available translations to `gettext.NullTranslations` object. 
 
## Templating

To format in Python, the sentences can use the `.format()` string.
For a proper documentation, click [here](https://pyformat.info/).

## Extracting Translations

You can extract translatable strings from Python files or modules with `python[3] manage.py translate [modules]`
command. As a result it creates a `locale/messages.pot` translation template in .POT format.
