# Generated from /home/mtdsousa/workspace/antlr4-verilog/build/grammars-v4/verilog/verilog/VerilogPreprocessorParser.g4 by ANTLR 4.9
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u0180")
        buf.write("\u00ef\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\3\2\7\2D\n\2\f\2\16\2G\13\2\3\3")
        buf.write("\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\3\3\3\5\3Y\n\3\3\4\3\4\3\4\3\5\3\5\3\5\3\6\3\6\3\6\3")
        buf.write("\6\3\7\3\7\3\b\3\b\3\b\3\b\7\bk\n\b\f\b\16\bn\13\b\3\t")
        buf.write("\3\t\3\t\5\ts\n\t\3\n\3\n\3\13\3\13\3\f\3\f\3\f\3\f\3")
        buf.write("\r\3\r\3\r\3\r\3\r\7\r\u0082\n\r\f\r\16\r\u0085\13\r\3")
        buf.write("\r\7\r\u0088\n\r\f\r\16\r\u008b\13\r\3\r\5\r\u008e\n\r")
        buf.write("\3\r\3\r\3\16\3\16\3\16\3\16\3\16\7\16\u0097\n\16\f\16")
        buf.write("\16\16\u009a\13\16\3\16\7\16\u009d\n\16\f\16\16\16\u00a0")
        buf.write("\13\16\3\16\5\16\u00a3\n\16\3\16\3\16\3\17\3\17\3\17\3")
        buf.write("\17\3\17\7\17\u00ac\n\17\f\17\16\17\u00af\13\17\3\20\3")
        buf.write("\20\3\20\3\20\7\20\u00b5\n\20\f\20\16\20\u00b8\13\20\3")
        buf.write("\21\3\21\3\21\3\22\3\22\3\22\3\22\3\23\3\23\3\24\3\24")
        buf.write("\3\24\3\25\3\25\3\25\3\25\3\25\3\25\3\26\3\26\3\27\3\27")
        buf.write("\3\30\3\30\3\30\3\30\3\30\3\30\3\31\3\31\3\31\3\32\3\32")
        buf.write("\3\33\3\33\3\34\3\34\3\34\3\34\3\35\3\35\3\36\3\36\3\36")
        buf.write("\3\37\3\37\3\37\3\37\3 \3 \3!\3!\3!\3!\2\2\"\2\4\6\b\n")
        buf.write("\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<")
        buf.write(">@\2\3\3\2\u017a\u017b\2\u00ec\2E\3\2\2\2\4X\3\2\2\2\6")
        buf.write("Z\3\2\2\2\b]\3\2\2\2\n`\3\2\2\2\fd\3\2\2\2\16f\3\2\2\2")
        buf.write("\20o\3\2\2\2\22t\3\2\2\2\24v\3\2\2\2\26x\3\2\2\2\30|\3")
        buf.write("\2\2\2\32\u0091\3\2\2\2\34\u00a6\3\2\2\2\36\u00b0\3\2")
        buf.write("\2\2 \u00b9\3\2\2\2\"\u00bc\3\2\2\2$\u00c0\3\2\2\2&\u00c2")
        buf.write("\3\2\2\2(\u00c5\3\2\2\2*\u00cb\3\2\2\2,\u00cd\3\2\2\2")
        buf.write(".\u00cf\3\2\2\2\60\u00d5\3\2\2\2\62\u00d8\3\2\2\2\64\u00da")
        buf.write("\3\2\2\2\66\u00dc\3\2\2\28\u00e0\3\2\2\2:\u00e2\3\2\2")
        buf.write("\2<\u00e5\3\2\2\2>\u00e9\3\2\2\2@\u00eb\3\2\2\2BD\5\4")
        buf.write("\3\2CB\3\2\2\2DG\3\2\2\2EC\3\2\2\2EF\3\2\2\2F\3\3\2\2")
        buf.write("\2GE\3\2\2\2HY\5\6\4\2IY\5\b\5\2JY\5\n\6\2KY\5\16\b\2")
        buf.write("LY\5\20\t\2MY\5\26\f\2NY\5\30\r\2OY\5\32\16\2PY\5\"\22")
        buf.write("\2QY\5&\24\2RY\5(\25\2SY\5.\30\2TY\5\66\34\2UY\5:\36\2")
        buf.write("VY\5<\37\2WY\5@!\2XH\3\2\2\2XI\3\2\2\2XJ\3\2\2\2XK\3\2")
        buf.write("\2\2XL\3\2\2\2XM\3\2\2\2XN\3\2\2\2XO\3\2\2\2XP\3\2\2\2")
        buf.write("XQ\3\2\2\2XR\3\2\2\2XS\3\2\2\2XT\3\2\2\2XU\3\2\2\2XV\3")
        buf.write("\2\2\2XW\3\2\2\2Y\5\3\2\2\2Z[\7\u0153\2\2[\\\7\u015f\2")
        buf.write("\2\\\7\3\2\2\2]^\7\u0153\2\2^_\7\u0165\2\2_\t\3\2\2\2")
        buf.write("`a\7\u0153\2\2ab\7\u0160\2\2bc\5\f\7\2c\13\3\2\2\2de\7")
        buf.write("\u0170\2\2e\r\3\2\2\2fg\7\u0153\2\2gh\7\u0161\2\2hl\5")
        buf.write("\24\13\2ik\t\2\2\2ji\3\2\2\2kn\3\2\2\2lj\3\2\2\2lm\3\2")
        buf.write("\2\2m\17\3\2\2\2nl\3\2\2\2op\7\u0153\2\2pr\5\24\13\2q")
        buf.write("s\5\22\n\2rq\3\2\2\2rs\3\2\2\2s\21\3\2\2\2tu\7\u017c\2")
        buf.write("\2u\23\3\2\2\2vw\7\u0175\2\2w\25\3\2\2\2xy\7\u0153\2\2")
        buf.write("yz\7\u016f\2\2z{\5\24\13\2{\27\3\2\2\2|}\7\u0153\2\2}")
        buf.write("~\7\u0167\2\2~\u0083\5\24\13\2\177\u0082\7\u017f\2\2\u0080")
        buf.write("\u0082\5\4\3\2\u0081\177\3\2\2\2\u0081\u0080\3\2\2\2\u0082")
        buf.write("\u0085\3\2\2\2\u0083\u0081\3\2\2\2\u0083\u0084\3\2\2\2")
        buf.write("\u0084\u0089\3\2\2\2\u0085\u0083\3\2\2\2\u0086\u0088\5")
        buf.write("\34\17\2\u0087\u0086\3\2\2\2\u0088\u008b\3\2\2\2\u0089")
        buf.write("\u0087\3\2\2\2\u0089\u008a\3\2\2\2\u008a\u008d\3\2\2\2")
        buf.write("\u008b\u0089\3\2\2\2\u008c\u008e\5\36\20\2\u008d\u008c")
        buf.write("\3\2\2\2\u008d\u008e\3\2\2\2\u008e\u008f\3\2\2\2\u008f")
        buf.write("\u0090\5 \21\2\u0090\31\3\2\2\2\u0091\u0092\7\u0153\2")
        buf.write("\2\u0092\u0093\7\u0168\2\2\u0093\u0098\5\24\13\2\u0094")
        buf.write("\u0097\7\u017f\2\2\u0095\u0097\5\4\3\2\u0096\u0094\3\2")
        buf.write("\2\2\u0096\u0095\3\2\2\2\u0097\u009a\3\2\2\2\u0098\u0096")
        buf.write("\3\2\2\2\u0098\u0099\3\2\2\2\u0099\u009e\3\2\2\2\u009a")
        buf.write("\u0098\3\2\2\2\u009b\u009d\5\34\17\2\u009c\u009b\3\2\2")
        buf.write("\2\u009d\u00a0\3\2\2\2\u009e\u009c\3\2\2\2\u009e\u009f")
        buf.write("\3\2\2\2\u009f\u00a2\3\2\2\2\u00a0\u009e\3\2\2\2\u00a1")
        buf.write("\u00a3\5\36\20\2\u00a2\u00a1\3\2\2\2\u00a2\u00a3\3\2\2")
        buf.write("\2\u00a3\u00a4\3\2\2\2\u00a4\u00a5\5 \21\2\u00a5\33\3")
        buf.write("\2\2\2\u00a6\u00a7\7\u0153\2\2\u00a7\u00a8\7\u0163\2\2")
        buf.write("\u00a8\u00ad\5\24\13\2\u00a9\u00ac\7\u017f\2\2\u00aa\u00ac")
        buf.write("\5\4\3\2\u00ab\u00a9\3\2\2\2\u00ab\u00aa\3\2\2\2\u00ac")
        buf.write("\u00af\3\2\2\2\u00ad\u00ab\3\2\2\2\u00ad\u00ae\3\2\2\2")
        buf.write("\u00ae\35\3\2\2\2\u00af\u00ad\3\2\2\2\u00b0\u00b1\7\u0153")
        buf.write("\2\2\u00b1\u00b6\7\u0162\2\2\u00b2\u00b5\7\u017f\2\2\u00b3")
        buf.write("\u00b5\5\4\3\2\u00b4\u00b2\3\2\2\2\u00b4\u00b3\3\2\2\2")
        buf.write("\u00b5\u00b8\3\2\2\2\u00b6\u00b4\3\2\2\2\u00b6\u00b7\3")
        buf.write("\2\2\2\u00b7\37\3\2\2\2\u00b8\u00b6\3\2\2\2\u00b9\u00ba")
        buf.write("\7\u0153\2\2\u00ba\u00bb\7\u0166\2\2\u00bb!\3\2\2\2\u00bc")
        buf.write("\u00bd\7\u0153\2\2\u00bd\u00be\7\u0169\2\2\u00be\u00bf")
        buf.write("\5$\23\2\u00bf#\3\2\2\2\u00c0\u00c1\7\u0174\2\2\u00c1")
        buf.write("%\3\2\2\2\u00c2\u00c3\7\u0153\2\2\u00c3\u00c4\7\u016c")
        buf.write("\2\2\u00c4\'\3\2\2\2\u00c5\u00c6\7\u0153\2\2\u00c6\u00c7")
        buf.write("\7\u016a\2\2\u00c7\u00c8\5*\26\2\u00c8\u00c9\5$\23\2\u00c9")
        buf.write("\u00ca\5,\27\2\u00ca)\3\2\2\2\u00cb\u00cc\7\u0173\2\2")
        buf.write("\u00cc+\3\2\2\2\u00cd\u00ce\7\u0173\2\2\u00ce-\3\2\2\2")
        buf.write("\u00cf\u00d0\7\u0153\2\2\u00d0\u00d1\7\u016d\2\2\u00d1")
        buf.write("\u00d2\5\60\31\2\u00d2\u00d3\7\u0176\2\2\u00d3\u00d4\5")
        buf.write("\60\31\2\u00d4/\3\2\2\2\u00d5\u00d6\5\62\32\2\u00d6\u00d7")
        buf.write("\5\64\33\2\u00d7\61\3\2\2\2\u00d8\u00d9\7\u0173\2\2\u00d9")
        buf.write("\63\3\2\2\2\u00da\u00db\7\u0171\2\2\u00db\65\3\2\2\2\u00dc")
        buf.write("\u00dd\7\u0153\2\2\u00dd\u00de\7\u016e\2\2\u00de\u00df")
        buf.write("\58\35\2\u00df\67\3\2\2\2\u00e0\u00e1\7\u0172\2\2\u00e1")
        buf.write("9\3\2\2\2\u00e2\u00e3\7\u0153\2\2\u00e3\u00e4\7\u016b")
        buf.write("\2\2\u00e4;\3\2\2\2\u00e5\u00e6\7\u0153\2\2\u00e6\u00e7")
        buf.write("\7\u015e\2\2\u00e7\u00e8\5> \2\u00e8=\3\2\2\2\u00e9\u00ea")
        buf.write("\7\u0174\2\2\u00ea?\3\2\2\2\u00eb\u00ec\7\u0153\2\2\u00ec")
        buf.write("\u00ed\7\u0164\2\2\u00edA\3\2\2\2\22EXlr\u0081\u0083\u0089")
        buf.write("\u008d\u0096\u0098\u009e\u00a2\u00ab\u00ad\u00b4\u00b6")
        return buf.getvalue()


class VerilogPreprocessorParser ( Parser ):

    grammarFileName = "VerilogPreprocessorParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'always'", "'and'", "'assign'", "'automatic'", 
                     "'begin'", "'buf'", "'bufif0'", "'bufif1'", "'case'", 
                     "'casex'", "'casez'", "'cell'", "'cmos'", "'config'", 
                     "'deassign'", "'default'", "'defparam'", "'design'", 
                     "'disable'", "'edge'", "'else'", "'end'", "'endcase'", 
                     "'endconfig'", "'endfunction'", "'endgenerate'", "'endmodule'", 
                     "'endprimitive'", "'endspecify'", "'endtable'", "'endtask'", 
                     "'event'", "'for'", "'force'", "'forever'", "'fork'", 
                     "'function'", "'generate'", "'genvar'", "'highz0'", 
                     "'highz1'", "'if'", "'ifnone'", "'incdir'", "<INVALID>", 
                     "'initial'", "'inout'", "'input'", "'instance'", "'integer'", 
                     "'join'", "'large'", "'liblist'", "'library'", "'localparam'", 
                     "'macromodule'", "'medium'", "'module'", "'nand'", 
                     "'negedge'", "'nmos'", "'nor'", "'noshowcancelled'", 
                     "'not'", "'notif0'", "'notif1'", "'or'", "'output'", 
                     "'parameter'", "'pmos'", "'posedge'", "'primitive'", 
                     "'pull0'", "'pull1'", "'pulldown'", "'pullup'", "'pulsestyle_onevent'", 
                     "'pulsestyle_ondetect'", "'rcmos'", "'real'", "'realtime'", 
                     "'reg'", "'release'", "'repeat'", "'rnmos'", "'rpmos'", 
                     "'rtran'", "'rtranif0'", "'rtranif1'", "'scalared'", 
                     "'showcancelled'", "'signed'", "'small'", "'specify'", 
                     "'specparam'", "'strong0'", "'strong1'", "'supply0'", 
                     "'supply1'", "'table'", "'task'", "'time'", "'tran'", 
                     "'tranif0'", "'tranif1'", "'tri'", "'tri0'", "'tri1'", 
                     "'triand'", "'trior'", "'trireg'", "'unsigned'", "'use'", 
                     "'uwire'", "'vectored'", "'wait'", "'wand'", "'weak0'", 
                     "'weak1'", "'while'", "'wire'", "'wor'", "'xnor'", 
                     "'xor'", "'$display'", "'$displayb'", "'$displayh'", 
                     "'$displayo'", "'$write'", "'$writeb'", "'$writeh'", 
                     "'$writeo'", "'$strobe'", "'$strobeb'", "'$strobeh'", 
                     "'$strobeo'", "'$monitor'", "'$monitorb'", "'$monitorh'", 
                     "'$monitoro'", "'$monitoroff'", "'$monitoron'", "'$fclose'", 
                     "'$fdisplay'", "'$fdisplayb'", "'$fdisplayh'", "'$fdisplayo'", 
                     "'$fstrobe'", "'$fstrobeb'", "'$fstrobeh'", "'$fstrobeo'", 
                     "'$swrite'", "'$swriteb'", "'$swriteh'", "'$swriteo'", 
                     "'$fscanf'", "'$fread'", "'$fseek'", "'$fflush'", "'$feof'", 
                     "'$sdf_annotate'", "'$fopen'", "'$fwrite'", "'$fwriteb'", 
                     "'$fwriteh'", "'$fwriteo'", "'$fmonitor'", "'$fmonitorb'", 
                     "'$fmonitorh'", "'$fmonitoro'", "'$sformat'", "'$fgetc'", 
                     "'$ungetc'", "'$fgets'", "'$sscanf'", "'$rewind'", 
                     "'$ftell'", "'$ferror'", "'$readmemb'", "'$readmemh'", 
                     "'$printtimescale'", "'$timeformat'", "'$finish'", 
                     "'$stop'", "'$async$and$array'", "'$async$nand$array'", 
                     "'$async$or$array'", "'$async$nor$array'", "'$sync$and$array'", 
                     "'$sync$nand$array'", "'$sync$or$array'", "'$sync$nor$array'", 
                     "'$async$and$plane'", "'$async$nand$plane'", "'$async$or$plane'", 
                     "'$async$nor$plane'", "'$sync$and$plane'", "'$sync$nand$plane'", 
                     "'$sync$or$plane'", "'$sync$nor$plane'", "'$q_initialize'", 
                     "'$q_remove'", "'$q_exam'", "'$q_add'", "'$q_full'", 
                     "'$realtime'", "'$time'", "'$stime'", "'$bitstoreal'", 
                     "'$itor'", "'$signed'", "'$realtobits'", "'$rtoi'", 
                     "'$unsigned'", "'$random'", "'$dist_erlang'", "'$dist_normal'", 
                     "'$dist_t'", "'$dist_chi_square'", "'$dist_exponential'", 
                     "'$dist_poisson'", "'$dist_uniform'", "'$test$plusargs'", 
                     "'$value$plusargs'", "'$clog2'", "'$ln'", "'$log10'", 
                     "'$exp'", "'$sqrt'", "'$pow'", "'$floor'", "'$ceil'", 
                     "'$sin'", "'$cos'", "'$tan'", "'$asin'", "'$acos'", 
                     "'$atan'", "'$atan2'", "'$hypot'", "'$sinh'", "'$cosh'", 
                     "'$tanh'", "'$asinh'", "'$acosh'", "'$atanh'", "'$dumpfile'", 
                     "'$dumpvars'", "'$dumpoff'", "'$dumpon'", "'$dumpall'", 
                     "'$dumplimit'", "'$dumpflush'", "'$end'", "'$comment'", 
                     "'$date'", "'$enddefinitions'", "'$scope'", "'$timescale'", 
                     "'$upscope'", "'$var'", "'$version'", "'$dumpports'", 
                     "'$dumpportsoff'", "'$dumpportson'", "'$dumpportsall'", 
                     "'$dumpportslimit'", "'$dumpportsflush'", "'$vcdclose'", 
                     "'$setup'", "'$hold'", "'$setuphold'", "'$recovery'", 
                     "'$removal'", "'$recrem'", "'$skew'", "'$timeskew'", 
                     "'$fullskew'", "'$period'", "'$width'", "'$nochange'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "'('", "')'", "'['", "']'", "'{'", "'}'", "'+'", "'-'", 
                     "'!'", "'~'", "'&'", "'~&'", "'|'", "'~|'", "'^'", 
                     "'~^'", "'^~'", "'*'", "'%'", "'=='", "'!='", "'==='", 
                     "'!=='", "'&&'", "'||'", "'**'", "'<'", "'<='", "'>'", 
                     "'>='", "'>>'", "'<<'", "'>>>'", "'<<<'", "'.'", "<INVALID>", 
                     "':'", "';'", "<INVALID>", "'='", "'?'", "'@'", "'#'", 
                     "<INVALID>", "'+:'", "'-:'", "'->'", "'=>'", "'*>'", 
                     "'&&&'", "'PATHPULSE$'", "<INVALID>", "'-incdir'", 
                     "<INVALID>", "'begin_keywords'", "'celldefine'", "'default_nettype'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "'end_keywords'", 
                     "'endcelldefine'", "'endif'", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "'line'", "'nounconnected_drive'", "'resetall'", 
                     "'timescale'", "'unconnected_drive'" ]

    symbolicNames = [ "<INVALID>", "ALWAYS", "AND", "ASSIGN", "AUTOMATIC", 
                      "BEGIN", "BUF", "BUFIF0", "BUFIF1", "CASE", "CASEX", 
                      "CASEZ", "CELL", "CMOS", "CONFIG", "DEASSIGN", "DEFAULT", 
                      "DEFPARAM", "DESIGN", "DISABLE", "EDGE", "ELSE", "END", 
                      "ENDCASE", "ENDCONFIG", "ENDFUNCTION", "ENDGENERATE", 
                      "ENDMODULE", "ENDPRIMITIVE", "ENDSPECIFY", "ENDTABLE", 
                      "ENDTASK", "EVENT", "FOR", "FORCE", "FOREVER", "FORK", 
                      "FUNCTION", "GENERATE", "GENVAR", "HIGHZ0", "HIGHZ1", 
                      "IF", "IFNONE", "INCDIR", "INCLUDE", "INITIAL", "INOUT", 
                      "INPUT", "INSTANCE", "INTEGER", "JOIN", "LARGE", "LIBLIST", 
                      "LIBRARY", "LOCALPARAM", "MACROMODULE", "MEDIUM", 
                      "MODULE", "NAND", "NEGEDGE", "NMOS", "NOR", "NOSHOWCANCELLED", 
                      "NOT", "NOTIF0", "NOTIF1", "OR", "OUTPUT", "PARAMETER", 
                      "PMOS", "POSEDGE", "PRIMITIVE", "PULL0", "PULL1", 
                      "PULLDOWN", "PULLUP", "PULSESTYLE_ONEVENT", "PULSESTYLE_ONDETECT", 
                      "RCMOS", "REAL", "REALTIME", "REG", "RELEASE", "REPEAT", 
                      "RNMOS", "RPMOS", "RTRAN", "RTRANIF0", "RTRANIF1", 
                      "SCALARED", "SHOWCANCELLED", "SIGNED", "SMALL", "SPECIFY", 
                      "SPECPARAM", "STRONG0", "STRONG1", "SUPPLY0", "SUPPLY1", 
                      "TABLE", "TASK", "TIME", "TRAN", "TRANIF0", "TRANIF1", 
                      "TRI", "TRI0", "TRI1", "TRIAND", "TRIOR", "TRIREG", 
                      "UNSIGNED", "USE", "UWIRE", "VECTORED", "WAIT", "WAND", 
                      "WEAK0", "WEAK1", "WHILE", "WIRE", "WOR", "XNOR", 
                      "XOR", "DOLLAR_DISPLAY", "DOLLAR_DISPLAYB", "DOLLAR_DISPLAYH", 
                      "DOLLAR_DISPLAYO", "DOLLAR_WRITE", "DOLLAR_WRITEB", 
                      "DOLLAR_WRITEH", "DOLLAR_WRITEO", "DOLLAR_STROBE", 
                      "DOLLAR_STROBEB", "DOLLAR_STROBEH", "DOLLAR_STROBEO", 
                      "DOLLAR_MONITOR", "DOLLAR_MONITORB", "DOLLAR_MONITORH", 
                      "DOLLAR_MONITORO", "DOLLAR_MONITOROFF", "DOLLAR_MONITORON", 
                      "DOLLAR_FCLOSE", "DOLLAR_FDISPLAY", "DOLLAR_FDISPLAYB", 
                      "DOLLAR_FDISPLAYH", "DOLLAR_FDISPLAYO", "DOLLAR_FSTROBE", 
                      "DOLLAR_FSTROBEB", "DOLLAR_FSTROBEH", "DOLLAR_FSTROBEO", 
                      "DOLLAR_SWRITE", "DOLLAR_SWRITEB", "DOLLAR_SWRITEH", 
                      "DOLLAR_SWRITEO", "DOLLAR_FSCANF", "DOLLAR_FREAD", 
                      "DOLLAR_FSEEK", "DOLLAR_FFLUSH", "DOLLAR_FEOF", "DOLLAR_SDF_ANNOTATE", 
                      "DOLLAR_FOPEN", "DOLLAR_FWRITE", "DOLLAR_FWRITEB", 
                      "DOLLAR_FWRITEH", "DOLLAR_FWRITEO", "DOLLAR_FMONITOR", 
                      "DOLLAR_FMONITORB", "DOLLAR_FMONITORH", "DOLLAR_FMONITORO", 
                      "DOLLAR_SFORMAT", "DOLLAR_FGETC", "DOLLAR_UNGETC", 
                      "DOLLAR_FGETS", "DOLLAR_SSCANF", "DOLLAR_REWIND", 
                      "DOLLAR_FTELL", "DOLLAR_FERROR", "DOLLAR_READMEMB", 
                      "DOLLAR_READMEMH", "DOLLAR_PRINTTIMESCALE", "DOLLAR_TIMEFORMAT", 
                      "DOLLAR_FINISH", "DOLLAR_STOP", "DOLLAR_ASYNC_AND_ARRAY", 
                      "DOLLAR_ASYNC_NAND_ARRAY", "DOLLAR_ASYNC_OR_ARRAY", 
                      "DOLLAR_ASYNC_NOR_ARRAY", "DOLLAR_SYNC_AND_ARRAY", 
                      "DOLLAR_SYNC_NAND_ARRAY", "DOLLAR_SYNC_OR_ARRAY", 
                      "DOLLAR_SYNC_NOR_ARRAY", "DOLLAR_ASYNC_AND_PLANE", 
                      "DOLLAR_ASYNC_NAND_PLANE", "DOLLAR_ASYNC_OR_PLANE", 
                      "DOLLAR_ASYNC_NOR_PLANE", "DOLLAR_SYNC_AND_PLANE", 
                      "DOLLAR_SYNC_NAND_PLANE", "DOLLAR_SYNC_OR_PLANE", 
                      "DOLLAR_SYNC_NOR_PLANE", "DOLLAR_Q_INITIALIZE", "DOLLAR_Q_REMOVE", 
                      "DOLLAR_Q_EXAM", "DOLLAR_Q_ADD", "DOLLAR_Q_FULL", 
                      "DOLLAR_REALTIME", "DOLLAR_TIME", "DOLLAR_STIME", 
                      "DOLLAR_BITSTOREAL", "DOLLAR_ITOR", "DOLLAR_SIGNED", 
                      "DOLLAR_REALTOBITS", "DOLLAR_RTOI", "DOLLAR_UNSIGNED", 
                      "DOLLAR_RANDOM", "DOLLAR_DIST_ERLANG", "DOLLAR_DIST_NORMAL", 
                      "DOLLAR_DIST_T", "DOLLAR_DIST_CHI_SQUARE", "DOLLAR_DIST_EXPONENTIAL", 
                      "DOLLAR_DIST_POISSON", "DOLLAR_DIST_UNIFORM", "DOLLAR_TEST_PLUSARGS", 
                      "DOLLAR_VALUE_PLUSARGS", "DOLLAR_CLOG2", "DOLLAR_LN", 
                      "DOLLAR_LOG10", "DOLLAR_EXP", "DOLLAR_SQRT", "DOLLAR_POW", 
                      "DOLLAR_FLOOR", "DOLLAR_CEIL", "DOLLAR_SIN", "DOLLAR_COS", 
                      "DOLLAR_TAN", "DOLLAR_ASIN", "DOLLAR_ACOS", "DOLLAR_ATAN", 
                      "DOLLAR_ATAN2", "DOLLAR_HYPOT", "DOLLAR_SINH", "DOLLAR_COSH", 
                      "DOLLAR_TANH", "DOLLAR_ASINH", "DOLLAR_ACOSH", "DOLLAR_ATANH", 
                      "DOLLAR_DUMPFILE", "DOLLAR_DUMPVARS", "DOLLAR_DUMPOFF", 
                      "DOLLAR_DUMPON", "DOLLAR_DUMPALL", "DOLLAR_DUMPLIMIT", 
                      "DOLLAR_DUMPFLUSH", "DOLLAR_END", "DOLLAR_COMMENT", 
                      "DOLLAR_DATE", "DOLLAR_ENDDEFINITIONS", "DOLLAR_SCOPE", 
                      "DOLLAR_TIMESCALE", "DOLLAR_UPSCOPE", "DOLLAR_VAR", 
                      "DOLLAR_VERSION", "DOLLAR_DUMPPORTS", "DOLLAR_DUMPPORTSOFF", 
                      "DOLLAR_DUMPPORTSON", "DOLLAR_DUMPPORTSALL", "DOLLAR_DUMPPORTSLIMIT", 
                      "DOLLAR_DUMPPORTSFLUSH", "DOLLAR_VCDCLOSE", "DOLLAR_SETUP", 
                      "DOLLAR_HOLD", "DOLLAR_SETUPHOLD", "DOLLAR_RECOVERY", 
                      "DOLLAR_REMOVAL", "DOLLAR_RECREM", "DOLLAR_SKEW", 
                      "DOLLAR_TIMESKEW", "DOLLAR_FULLSKEW", "DOLLAR_PERIOD", 
                      "DOLLAR_WIDTH", "DOLLAR_NOCHANGE", "REAL_NUMBER", 
                      "DECIMAL_NUMBER", "BINARY_NUMBER", "OCTAL_NUMBER", 
                      "HEX_NUMBER", "STRING", "ONE_LINE_COMMENT", "BLOCK_COMMENT", 
                      "ESCAPED_IDENTIFIER", "SIMPLE_IDENTIFIER", "SYSTEM_TF_IDENTIFIER", 
                      "WHITE_SPACE_REGION", "LEFT_PARENTHESIS", "RIGHT_PARENTHESIS", 
                      "LEFT_BRACKET", "RIGHT_BRACKET", "LEFT_BRACE", "RIGHT_BRACE", 
                      "PLUS", "MINUS", "EXCLAMATION_MARK", "TILDE", "AMPERSAND", 
                      "TILDE_AMPERSAND", "VERTICAL_BAR", "TILDE_VERTICAL_BAR", 
                      "CARET", "TILDE_CARET", "CARET_TILDE", "ASTERISK", 
                      "PERCENT", "DOUBLE_EQUAL", "EXCLAMATION_MARK_EQUAL", 
                      "TRIPLE_EQUAL", "EXCLAMATION_MARK_DOUBLE_EQUAL", "DOUBLE_AMPERSAND", 
                      "DOUBLE_VERTICAL_BAR", "DOUBLE_ASTERISK", "LESS_THAN", 
                      "LESS_THAN_EQUAL", "GREATER_THAN", "GREATER_THAN_EQUAL", 
                      "DOUBLE_GREATER_THAN", "DOUBLE_LESS_THAN", "TRIPLE_GREATER_THAN", 
                      "TRIPLE_LESS_THAN", "DOT", "COMMA", "COLON", "SEMICOLON", 
                      "SLASH", "EQUAL", "QUESTION_MARK", "AT", "HASH", "GRAVE_ACCENT", 
                      "PLUS_COLON", "MINUS_COLON", "MINUS_GREATER_THAN", 
                      "EQUAL_GREATER_THAN", "ASTERISK_GREATER_THAN", "TRIPLE_AMPERSAND", 
                      "PATHPULSE_DOLLAR", "FILE_PATH_SPEC", "MINUS_INCDIR", 
                      "LIBRARY_NEWLINE", "DIRECTIVE_BEGIN_KEYWORDS", "DIRECTIVE_CELLDEFINE", 
                      "DIRECTIVE_DEFAULT_NETTYPE", "DIRECTIVE_DEFINE", "DIRECTIVE_ELSE", 
                      "DIRECTIVE_ELSIF", "DIRECTIVE_END_KEYWORDS", "DIRECTIVE_ENDCELLDEFINE", 
                      "DIRECTIVE_ENDIF", "DIRECTIVE_IFDEF", "DIRECTIVE_IFNDEF", 
                      "DIRECTIVE_INCLUDE", "DIRECTIVE_LINE", "DIRECTIVE_NOUNCONNECTED_DRIVE", 
                      "DIRECTIVE_RESETALL", "DIRECTIVE_TIMESCALE", "DIRECTIVE_UNCONNECTED_DRIVE", 
                      "DIRECTIVE_UNDEF", "DEFAULT_NETTYPE_VALUE", "TIME_UNIT", 
                      "UNCONNECTED_DRIVE_VALUE", "DIRECTIVE_NUMBER", "DIRECTIVE_STRING", 
                      "DIRECTIVE_IDENTIFIER", "DIRECTIVE_SLASH", "DIRECTIVE_COMMENT", 
                      "DIRECTIVE_WHITE_SPACE", "DIRECTIVE_NEWLINE", "MACRO_TEXT", 
                      "MACRO_TEXT_BACKSLASH_NEWLINE", "DIRECTIVE_LIST_OF_ARGUMENTS", 
                      "MACRO_USAGE_BACKSLASH_NEWLINE", "ANY_OTHER_TOKEN", 
                      "SOURCE_TEXT", "SOURCE_TEXT_BACKSLASH_NEWLINE" ]

    RULE_source_text = 0
    RULE_compiler_directive = 1
    RULE_celldefine_compiler_directive = 2
    RULE_endcelldefine_compiler_directive = 3
    RULE_default_nettype_compiler_directive = 4
    RULE_default_nettype_value = 5
    RULE_text_macro_definition = 6
    RULE_text_macro_usage = 7
    RULE_macro_list_of_actual_arguments = 8
    RULE_text_macro_identifier = 9
    RULE_undefine_compiler_directive = 10
    RULE_ifdef_directive = 11
    RULE_ifndef_directive = 12
    RULE_elsif_directive = 13
    RULE_else_directive = 14
    RULE_endif_directive = 15
    RULE_include_compiler_directive = 16
    RULE_filename = 17
    RULE_resetall_compiler_directive = 18
    RULE_line_compiler_directive = 19
    RULE_line_number = 20
    RULE_line_level = 21
    RULE_timescale_compiler_directive = 22
    RULE_time_literal = 23
    RULE_time_number = 24
    RULE_time_unit = 25
    RULE_unconnected_drive_compiler_directive = 26
    RULE_unconnected_drive_value = 27
    RULE_nounconnected_drive_compiler_directive = 28
    RULE_keywords_directive = 29
    RULE_version_specifier = 30
    RULE_endkeywords_directive = 31

    ruleNames =  [ "source_text", "compiler_directive", "celldefine_compiler_directive", 
                   "endcelldefine_compiler_directive", "default_nettype_compiler_directive", 
                   "default_nettype_value", "text_macro_definition", "text_macro_usage", 
                   "macro_list_of_actual_arguments", "text_macro_identifier", 
                   "undefine_compiler_directive", "ifdef_directive", "ifndef_directive", 
                   "elsif_directive", "else_directive", "endif_directive", 
                   "include_compiler_directive", "filename", "resetall_compiler_directive", 
                   "line_compiler_directive", "line_number", "line_level", 
                   "timescale_compiler_directive", "time_literal", "time_number", 
                   "time_unit", "unconnected_drive_compiler_directive", 
                   "unconnected_drive_value", "nounconnected_drive_compiler_directive", 
                   "keywords_directive", "version_specifier", "endkeywords_directive" ]

    EOF = Token.EOF
    ALWAYS=1
    AND=2
    ASSIGN=3
    AUTOMATIC=4
    BEGIN=5
    BUF=6
    BUFIF0=7
    BUFIF1=8
    CASE=9
    CASEX=10
    CASEZ=11
    CELL=12
    CMOS=13
    CONFIG=14
    DEASSIGN=15
    DEFAULT=16
    DEFPARAM=17
    DESIGN=18
    DISABLE=19
    EDGE=20
    ELSE=21
    END=22
    ENDCASE=23
    ENDCONFIG=24
    ENDFUNCTION=25
    ENDGENERATE=26
    ENDMODULE=27
    ENDPRIMITIVE=28
    ENDSPECIFY=29
    ENDTABLE=30
    ENDTASK=31
    EVENT=32
    FOR=33
    FORCE=34
    FOREVER=35
    FORK=36
    FUNCTION=37
    GENERATE=38
    GENVAR=39
    HIGHZ0=40
    HIGHZ1=41
    IF=42
    IFNONE=43
    INCDIR=44
    INCLUDE=45
    INITIAL=46
    INOUT=47
    INPUT=48
    INSTANCE=49
    INTEGER=50
    JOIN=51
    LARGE=52
    LIBLIST=53
    LIBRARY=54
    LOCALPARAM=55
    MACROMODULE=56
    MEDIUM=57
    MODULE=58
    NAND=59
    NEGEDGE=60
    NMOS=61
    NOR=62
    NOSHOWCANCELLED=63
    NOT=64
    NOTIF0=65
    NOTIF1=66
    OR=67
    OUTPUT=68
    PARAMETER=69
    PMOS=70
    POSEDGE=71
    PRIMITIVE=72
    PULL0=73
    PULL1=74
    PULLDOWN=75
    PULLUP=76
    PULSESTYLE_ONEVENT=77
    PULSESTYLE_ONDETECT=78
    RCMOS=79
    REAL=80
    REALTIME=81
    REG=82
    RELEASE=83
    REPEAT=84
    RNMOS=85
    RPMOS=86
    RTRAN=87
    RTRANIF0=88
    RTRANIF1=89
    SCALARED=90
    SHOWCANCELLED=91
    SIGNED=92
    SMALL=93
    SPECIFY=94
    SPECPARAM=95
    STRONG0=96
    STRONG1=97
    SUPPLY0=98
    SUPPLY1=99
    TABLE=100
    TASK=101
    TIME=102
    TRAN=103
    TRANIF0=104
    TRANIF1=105
    TRI=106
    TRI0=107
    TRI1=108
    TRIAND=109
    TRIOR=110
    TRIREG=111
    UNSIGNED=112
    USE=113
    UWIRE=114
    VECTORED=115
    WAIT=116
    WAND=117
    WEAK0=118
    WEAK1=119
    WHILE=120
    WIRE=121
    WOR=122
    XNOR=123
    XOR=124
    DOLLAR_DISPLAY=125
    DOLLAR_DISPLAYB=126
    DOLLAR_DISPLAYH=127
    DOLLAR_DISPLAYO=128
    DOLLAR_WRITE=129
    DOLLAR_WRITEB=130
    DOLLAR_WRITEH=131
    DOLLAR_WRITEO=132
    DOLLAR_STROBE=133
    DOLLAR_STROBEB=134
    DOLLAR_STROBEH=135
    DOLLAR_STROBEO=136
    DOLLAR_MONITOR=137
    DOLLAR_MONITORB=138
    DOLLAR_MONITORH=139
    DOLLAR_MONITORO=140
    DOLLAR_MONITOROFF=141
    DOLLAR_MONITORON=142
    DOLLAR_FCLOSE=143
    DOLLAR_FDISPLAY=144
    DOLLAR_FDISPLAYB=145
    DOLLAR_FDISPLAYH=146
    DOLLAR_FDISPLAYO=147
    DOLLAR_FSTROBE=148
    DOLLAR_FSTROBEB=149
    DOLLAR_FSTROBEH=150
    DOLLAR_FSTROBEO=151
    DOLLAR_SWRITE=152
    DOLLAR_SWRITEB=153
    DOLLAR_SWRITEH=154
    DOLLAR_SWRITEO=155
    DOLLAR_FSCANF=156
    DOLLAR_FREAD=157
    DOLLAR_FSEEK=158
    DOLLAR_FFLUSH=159
    DOLLAR_FEOF=160
    DOLLAR_SDF_ANNOTATE=161
    DOLLAR_FOPEN=162
    DOLLAR_FWRITE=163
    DOLLAR_FWRITEB=164
    DOLLAR_FWRITEH=165
    DOLLAR_FWRITEO=166
    DOLLAR_FMONITOR=167
    DOLLAR_FMONITORB=168
    DOLLAR_FMONITORH=169
    DOLLAR_FMONITORO=170
    DOLLAR_SFORMAT=171
    DOLLAR_FGETC=172
    DOLLAR_UNGETC=173
    DOLLAR_FGETS=174
    DOLLAR_SSCANF=175
    DOLLAR_REWIND=176
    DOLLAR_FTELL=177
    DOLLAR_FERROR=178
    DOLLAR_READMEMB=179
    DOLLAR_READMEMH=180
    DOLLAR_PRINTTIMESCALE=181
    DOLLAR_TIMEFORMAT=182
    DOLLAR_FINISH=183
    DOLLAR_STOP=184
    DOLLAR_ASYNC_AND_ARRAY=185
    DOLLAR_ASYNC_NAND_ARRAY=186
    DOLLAR_ASYNC_OR_ARRAY=187
    DOLLAR_ASYNC_NOR_ARRAY=188
    DOLLAR_SYNC_AND_ARRAY=189
    DOLLAR_SYNC_NAND_ARRAY=190
    DOLLAR_SYNC_OR_ARRAY=191
    DOLLAR_SYNC_NOR_ARRAY=192
    DOLLAR_ASYNC_AND_PLANE=193
    DOLLAR_ASYNC_NAND_PLANE=194
    DOLLAR_ASYNC_OR_PLANE=195
    DOLLAR_ASYNC_NOR_PLANE=196
    DOLLAR_SYNC_AND_PLANE=197
    DOLLAR_SYNC_NAND_PLANE=198
    DOLLAR_SYNC_OR_PLANE=199
    DOLLAR_SYNC_NOR_PLANE=200
    DOLLAR_Q_INITIALIZE=201
    DOLLAR_Q_REMOVE=202
    DOLLAR_Q_EXAM=203
    DOLLAR_Q_ADD=204
    DOLLAR_Q_FULL=205
    DOLLAR_REALTIME=206
    DOLLAR_TIME=207
    DOLLAR_STIME=208
    DOLLAR_BITSTOREAL=209
    DOLLAR_ITOR=210
    DOLLAR_SIGNED=211
    DOLLAR_REALTOBITS=212
    DOLLAR_RTOI=213
    DOLLAR_UNSIGNED=214
    DOLLAR_RANDOM=215
    DOLLAR_DIST_ERLANG=216
    DOLLAR_DIST_NORMAL=217
    DOLLAR_DIST_T=218
    DOLLAR_DIST_CHI_SQUARE=219
    DOLLAR_DIST_EXPONENTIAL=220
    DOLLAR_DIST_POISSON=221
    DOLLAR_DIST_UNIFORM=222
    DOLLAR_TEST_PLUSARGS=223
    DOLLAR_VALUE_PLUSARGS=224
    DOLLAR_CLOG2=225
    DOLLAR_LN=226
    DOLLAR_LOG10=227
    DOLLAR_EXP=228
    DOLLAR_SQRT=229
    DOLLAR_POW=230
    DOLLAR_FLOOR=231
    DOLLAR_CEIL=232
    DOLLAR_SIN=233
    DOLLAR_COS=234
    DOLLAR_TAN=235
    DOLLAR_ASIN=236
    DOLLAR_ACOS=237
    DOLLAR_ATAN=238
    DOLLAR_ATAN2=239
    DOLLAR_HYPOT=240
    DOLLAR_SINH=241
    DOLLAR_COSH=242
    DOLLAR_TANH=243
    DOLLAR_ASINH=244
    DOLLAR_ACOSH=245
    DOLLAR_ATANH=246
    DOLLAR_DUMPFILE=247
    DOLLAR_DUMPVARS=248
    DOLLAR_DUMPOFF=249
    DOLLAR_DUMPON=250
    DOLLAR_DUMPALL=251
    DOLLAR_DUMPLIMIT=252
    DOLLAR_DUMPFLUSH=253
    DOLLAR_END=254
    DOLLAR_COMMENT=255
    DOLLAR_DATE=256
    DOLLAR_ENDDEFINITIONS=257
    DOLLAR_SCOPE=258
    DOLLAR_TIMESCALE=259
    DOLLAR_UPSCOPE=260
    DOLLAR_VAR=261
    DOLLAR_VERSION=262
    DOLLAR_DUMPPORTS=263
    DOLLAR_DUMPPORTSOFF=264
    DOLLAR_DUMPPORTSON=265
    DOLLAR_DUMPPORTSALL=266
    DOLLAR_DUMPPORTSLIMIT=267
    DOLLAR_DUMPPORTSFLUSH=268
    DOLLAR_VCDCLOSE=269
    DOLLAR_SETUP=270
    DOLLAR_HOLD=271
    DOLLAR_SETUPHOLD=272
    DOLLAR_RECOVERY=273
    DOLLAR_REMOVAL=274
    DOLLAR_RECREM=275
    DOLLAR_SKEW=276
    DOLLAR_TIMESKEW=277
    DOLLAR_FULLSKEW=278
    DOLLAR_PERIOD=279
    DOLLAR_WIDTH=280
    DOLLAR_NOCHANGE=281
    REAL_NUMBER=282
    DECIMAL_NUMBER=283
    BINARY_NUMBER=284
    OCTAL_NUMBER=285
    HEX_NUMBER=286
    STRING=287
    ONE_LINE_COMMENT=288
    BLOCK_COMMENT=289
    ESCAPED_IDENTIFIER=290
    SIMPLE_IDENTIFIER=291
    SYSTEM_TF_IDENTIFIER=292
    WHITE_SPACE_REGION=293
    LEFT_PARENTHESIS=294
    RIGHT_PARENTHESIS=295
    LEFT_BRACKET=296
    RIGHT_BRACKET=297
    LEFT_BRACE=298
    RIGHT_BRACE=299
    PLUS=300
    MINUS=301
    EXCLAMATION_MARK=302
    TILDE=303
    AMPERSAND=304
    TILDE_AMPERSAND=305
    VERTICAL_BAR=306
    TILDE_VERTICAL_BAR=307
    CARET=308
    TILDE_CARET=309
    CARET_TILDE=310
    ASTERISK=311
    PERCENT=312
    DOUBLE_EQUAL=313
    EXCLAMATION_MARK_EQUAL=314
    TRIPLE_EQUAL=315
    EXCLAMATION_MARK_DOUBLE_EQUAL=316
    DOUBLE_AMPERSAND=317
    DOUBLE_VERTICAL_BAR=318
    DOUBLE_ASTERISK=319
    LESS_THAN=320
    LESS_THAN_EQUAL=321
    GREATER_THAN=322
    GREATER_THAN_EQUAL=323
    DOUBLE_GREATER_THAN=324
    DOUBLE_LESS_THAN=325
    TRIPLE_GREATER_THAN=326
    TRIPLE_LESS_THAN=327
    DOT=328
    COMMA=329
    COLON=330
    SEMICOLON=331
    SLASH=332
    EQUAL=333
    QUESTION_MARK=334
    AT=335
    HASH=336
    GRAVE_ACCENT=337
    PLUS_COLON=338
    MINUS_COLON=339
    MINUS_GREATER_THAN=340
    EQUAL_GREATER_THAN=341
    ASTERISK_GREATER_THAN=342
    TRIPLE_AMPERSAND=343
    PATHPULSE_DOLLAR=344
    FILE_PATH_SPEC=345
    MINUS_INCDIR=346
    LIBRARY_NEWLINE=347
    DIRECTIVE_BEGIN_KEYWORDS=348
    DIRECTIVE_CELLDEFINE=349
    DIRECTIVE_DEFAULT_NETTYPE=350
    DIRECTIVE_DEFINE=351
    DIRECTIVE_ELSE=352
    DIRECTIVE_ELSIF=353
    DIRECTIVE_END_KEYWORDS=354
    DIRECTIVE_ENDCELLDEFINE=355
    DIRECTIVE_ENDIF=356
    DIRECTIVE_IFDEF=357
    DIRECTIVE_IFNDEF=358
    DIRECTIVE_INCLUDE=359
    DIRECTIVE_LINE=360
    DIRECTIVE_NOUNCONNECTED_DRIVE=361
    DIRECTIVE_RESETALL=362
    DIRECTIVE_TIMESCALE=363
    DIRECTIVE_UNCONNECTED_DRIVE=364
    DIRECTIVE_UNDEF=365
    DEFAULT_NETTYPE_VALUE=366
    TIME_UNIT=367
    UNCONNECTED_DRIVE_VALUE=368
    DIRECTIVE_NUMBER=369
    DIRECTIVE_STRING=370
    DIRECTIVE_IDENTIFIER=371
    DIRECTIVE_SLASH=372
    DIRECTIVE_COMMENT=373
    DIRECTIVE_WHITE_SPACE=374
    DIRECTIVE_NEWLINE=375
    MACRO_TEXT=376
    MACRO_TEXT_BACKSLASH_NEWLINE=377
    DIRECTIVE_LIST_OF_ARGUMENTS=378
    MACRO_USAGE_BACKSLASH_NEWLINE=379
    ANY_OTHER_TOKEN=380
    SOURCE_TEXT=381
    SOURCE_TEXT_BACKSLASH_NEWLINE=382

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Source_textContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compiler_directive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreprocessorParser.Compiler_directiveContext)
            else:
                return self.getTypedRuleContext(VerilogPreprocessorParser.Compiler_directiveContext,i)


        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_source_text

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSource_text" ):
                listener.enterSource_text(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSource_text" ):
                listener.exitSource_text(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSource_text" ):
                return visitor.visitSource_text(self)
            else:
                return visitor.visitChildren(self)




    def source_text(self):

        localctx = VerilogPreprocessorParser.Source_textContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_source_text)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 67
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==VerilogPreprocessorParser.GRAVE_ACCENT:
                self.state = 64
                self.compiler_directive()
                self.state = 69
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Compiler_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def celldefine_compiler_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Celldefine_compiler_directiveContext,0)


        def endcelldefine_compiler_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Endcelldefine_compiler_directiveContext,0)


        def default_nettype_compiler_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Default_nettype_compiler_directiveContext,0)


        def text_macro_definition(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Text_macro_definitionContext,0)


        def text_macro_usage(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Text_macro_usageContext,0)


        def undefine_compiler_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Undefine_compiler_directiveContext,0)


        def ifdef_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Ifdef_directiveContext,0)


        def ifndef_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Ifndef_directiveContext,0)


        def include_compiler_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Include_compiler_directiveContext,0)


        def resetall_compiler_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Resetall_compiler_directiveContext,0)


        def line_compiler_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Line_compiler_directiveContext,0)


        def timescale_compiler_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Timescale_compiler_directiveContext,0)


        def unconnected_drive_compiler_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Unconnected_drive_compiler_directiveContext,0)


        def nounconnected_drive_compiler_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Nounconnected_drive_compiler_directiveContext,0)


        def keywords_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Keywords_directiveContext,0)


        def endkeywords_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Endkeywords_directiveContext,0)


        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_compiler_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompiler_directive" ):
                listener.enterCompiler_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompiler_directive" ):
                listener.exitCompiler_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompiler_directive" ):
                return visitor.visitCompiler_directive(self)
            else:
                return visitor.visitChildren(self)




    def compiler_directive(self):

        localctx = VerilogPreprocessorParser.Compiler_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_compiler_directive)
        try:
            self.state = 86
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 70
                self.celldefine_compiler_directive()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 71
                self.endcelldefine_compiler_directive()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 72
                self.default_nettype_compiler_directive()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 73
                self.text_macro_definition()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 74
                self.text_macro_usage()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 75
                self.undefine_compiler_directive()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 76
                self.ifdef_directive()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 77
                self.ifndef_directive()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 78
                self.include_compiler_directive()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 79
                self.resetall_compiler_directive()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 80
                self.line_compiler_directive()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 81
                self.timescale_compiler_directive()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 82
                self.unconnected_drive_compiler_directive()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 83
                self.nounconnected_drive_compiler_directive()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 84
                self.keywords_directive()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 85
                self.endkeywords_directive()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Celldefine_compiler_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_CELLDEFINE(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_CELLDEFINE, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_celldefine_compiler_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCelldefine_compiler_directive" ):
                listener.enterCelldefine_compiler_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCelldefine_compiler_directive" ):
                listener.exitCelldefine_compiler_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCelldefine_compiler_directive" ):
                return visitor.visitCelldefine_compiler_directive(self)
            else:
                return visitor.visitChildren(self)




    def celldefine_compiler_directive(self):

        localctx = VerilogPreprocessorParser.Celldefine_compiler_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_celldefine_compiler_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 88
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 89
            self.match(VerilogPreprocessorParser.DIRECTIVE_CELLDEFINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Endcelldefine_compiler_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_ENDCELLDEFINE(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_ENDCELLDEFINE, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_endcelldefine_compiler_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndcelldefine_compiler_directive" ):
                listener.enterEndcelldefine_compiler_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndcelldefine_compiler_directive" ):
                listener.exitEndcelldefine_compiler_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndcelldefine_compiler_directive" ):
                return visitor.visitEndcelldefine_compiler_directive(self)
            else:
                return visitor.visitChildren(self)




    def endcelldefine_compiler_directive(self):

        localctx = VerilogPreprocessorParser.Endcelldefine_compiler_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_endcelldefine_compiler_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 91
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 92
            self.match(VerilogPreprocessorParser.DIRECTIVE_ENDCELLDEFINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Default_nettype_compiler_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_DEFAULT_NETTYPE(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_DEFAULT_NETTYPE, 0)

        def default_nettype_value(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Default_nettype_valueContext,0)


        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_default_nettype_compiler_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault_nettype_compiler_directive" ):
                listener.enterDefault_nettype_compiler_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault_nettype_compiler_directive" ):
                listener.exitDefault_nettype_compiler_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefault_nettype_compiler_directive" ):
                return visitor.visitDefault_nettype_compiler_directive(self)
            else:
                return visitor.visitChildren(self)




    def default_nettype_compiler_directive(self):

        localctx = VerilogPreprocessorParser.Default_nettype_compiler_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_default_nettype_compiler_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 94
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 95
            self.match(VerilogPreprocessorParser.DIRECTIVE_DEFAULT_NETTYPE)
            self.state = 96
            self.default_nettype_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Default_nettype_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFAULT_NETTYPE_VALUE(self):
            return self.getToken(VerilogPreprocessorParser.DEFAULT_NETTYPE_VALUE, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_default_nettype_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefault_nettype_value" ):
                listener.enterDefault_nettype_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefault_nettype_value" ):
                listener.exitDefault_nettype_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefault_nettype_value" ):
                return visitor.visitDefault_nettype_value(self)
            else:
                return visitor.visitChildren(self)




    def default_nettype_value(self):

        localctx = VerilogPreprocessorParser.Default_nettype_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_default_nettype_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self.match(VerilogPreprocessorParser.DEFAULT_NETTYPE_VALUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Text_macro_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_DEFINE(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_DEFINE, 0)

        def text_macro_identifier(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Text_macro_identifierContext,0)


        def MACRO_TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(VerilogPreprocessorParser.MACRO_TEXT)
            else:
                return self.getToken(VerilogPreprocessorParser.MACRO_TEXT, i)

        def MACRO_TEXT_BACKSLASH_NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(VerilogPreprocessorParser.MACRO_TEXT_BACKSLASH_NEWLINE)
            else:
                return self.getToken(VerilogPreprocessorParser.MACRO_TEXT_BACKSLASH_NEWLINE, i)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_text_macro_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterText_macro_definition" ):
                listener.enterText_macro_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitText_macro_definition" ):
                listener.exitText_macro_definition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitText_macro_definition" ):
                return visitor.visitText_macro_definition(self)
            else:
                return visitor.visitChildren(self)




    def text_macro_definition(self):

        localctx = VerilogPreprocessorParser.Text_macro_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_text_macro_definition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 100
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 101
            self.match(VerilogPreprocessorParser.DIRECTIVE_DEFINE)
            self.state = 102
            self.text_macro_identifier()
            self.state = 106
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==VerilogPreprocessorParser.MACRO_TEXT or _la==VerilogPreprocessorParser.MACRO_TEXT_BACKSLASH_NEWLINE:
                self.state = 103
                _la = self._input.LA(1)
                if not(_la==VerilogPreprocessorParser.MACRO_TEXT or _la==VerilogPreprocessorParser.MACRO_TEXT_BACKSLASH_NEWLINE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 108
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Text_macro_usageContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def text_macro_identifier(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Text_macro_identifierContext,0)


        def macro_list_of_actual_arguments(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Macro_list_of_actual_argumentsContext,0)


        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_text_macro_usage

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterText_macro_usage" ):
                listener.enterText_macro_usage(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitText_macro_usage" ):
                listener.exitText_macro_usage(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitText_macro_usage" ):
                return visitor.visitText_macro_usage(self)
            else:
                return visitor.visitChildren(self)




    def text_macro_usage(self):

        localctx = VerilogPreprocessorParser.Text_macro_usageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_text_macro_usage)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 109
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 110
            self.text_macro_identifier()
            self.state = 112
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==VerilogPreprocessorParser.DIRECTIVE_LIST_OF_ARGUMENTS:
                self.state = 111
                self.macro_list_of_actual_arguments()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Macro_list_of_actual_argumentsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIRECTIVE_LIST_OF_ARGUMENTS(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_LIST_OF_ARGUMENTS, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_macro_list_of_actual_arguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMacro_list_of_actual_arguments" ):
                listener.enterMacro_list_of_actual_arguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMacro_list_of_actual_arguments" ):
                listener.exitMacro_list_of_actual_arguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMacro_list_of_actual_arguments" ):
                return visitor.visitMacro_list_of_actual_arguments(self)
            else:
                return visitor.visitChildren(self)




    def macro_list_of_actual_arguments(self):

        localctx = VerilogPreprocessorParser.Macro_list_of_actual_argumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_macro_list_of_actual_arguments)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 114
            self.match(VerilogPreprocessorParser.DIRECTIVE_LIST_OF_ARGUMENTS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Text_macro_identifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIRECTIVE_IDENTIFIER(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_IDENTIFIER, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_text_macro_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterText_macro_identifier" ):
                listener.enterText_macro_identifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitText_macro_identifier" ):
                listener.exitText_macro_identifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitText_macro_identifier" ):
                return visitor.visitText_macro_identifier(self)
            else:
                return visitor.visitChildren(self)




    def text_macro_identifier(self):

        localctx = VerilogPreprocessorParser.Text_macro_identifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_text_macro_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 116
            self.match(VerilogPreprocessorParser.DIRECTIVE_IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Undefine_compiler_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_UNDEF(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_UNDEF, 0)

        def text_macro_identifier(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Text_macro_identifierContext,0)


        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_undefine_compiler_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUndefine_compiler_directive" ):
                listener.enterUndefine_compiler_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUndefine_compiler_directive" ):
                listener.exitUndefine_compiler_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUndefine_compiler_directive" ):
                return visitor.visitUndefine_compiler_directive(self)
            else:
                return visitor.visitChildren(self)




    def undefine_compiler_directive(self):

        localctx = VerilogPreprocessorParser.Undefine_compiler_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_undefine_compiler_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 118
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 119
            self.match(VerilogPreprocessorParser.DIRECTIVE_UNDEF)
            self.state = 120
            self.text_macro_identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ifdef_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_IFDEF(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_IFDEF, 0)

        def text_macro_identifier(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Text_macro_identifierContext,0)


        def endif_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Endif_directiveContext,0)


        def SOURCE_TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(VerilogPreprocessorParser.SOURCE_TEXT)
            else:
                return self.getToken(VerilogPreprocessorParser.SOURCE_TEXT, i)

        def compiler_directive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreprocessorParser.Compiler_directiveContext)
            else:
                return self.getTypedRuleContext(VerilogPreprocessorParser.Compiler_directiveContext,i)


        def elsif_directive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreprocessorParser.Elsif_directiveContext)
            else:
                return self.getTypedRuleContext(VerilogPreprocessorParser.Elsif_directiveContext,i)


        def else_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Else_directiveContext,0)


        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_ifdef_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfdef_directive" ):
                listener.enterIfdef_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfdef_directive" ):
                listener.exitIfdef_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfdef_directive" ):
                return visitor.visitIfdef_directive(self)
            else:
                return visitor.visitChildren(self)




    def ifdef_directive(self):

        localctx = VerilogPreprocessorParser.Ifdef_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_ifdef_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 123
            self.match(VerilogPreprocessorParser.DIRECTIVE_IFDEF)
            self.state = 124
            self.text_macro_identifier()
            self.state = 129
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 127
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [VerilogPreprocessorParser.SOURCE_TEXT]:
                        self.state = 125
                        self.match(VerilogPreprocessorParser.SOURCE_TEXT)
                        pass
                    elif token in [VerilogPreprocessorParser.GRAVE_ACCENT]:
                        self.state = 126
                        self.compiler_directive()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 131
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

            self.state = 135
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,6,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 132
                    self.elsif_directive() 
                self.state = 137
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,6,self._ctx)

            self.state = 139
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.state = 138
                self.else_directive()


            self.state = 141
            self.endif_directive()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ifndef_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_IFNDEF(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_IFNDEF, 0)

        def text_macro_identifier(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Text_macro_identifierContext,0)


        def endif_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Endif_directiveContext,0)


        def SOURCE_TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(VerilogPreprocessorParser.SOURCE_TEXT)
            else:
                return self.getToken(VerilogPreprocessorParser.SOURCE_TEXT, i)

        def compiler_directive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreprocessorParser.Compiler_directiveContext)
            else:
                return self.getTypedRuleContext(VerilogPreprocessorParser.Compiler_directiveContext,i)


        def elsif_directive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreprocessorParser.Elsif_directiveContext)
            else:
                return self.getTypedRuleContext(VerilogPreprocessorParser.Elsif_directiveContext,i)


        def else_directive(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Else_directiveContext,0)


        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_ifndef_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfndef_directive" ):
                listener.enterIfndef_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfndef_directive" ):
                listener.exitIfndef_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfndef_directive" ):
                return visitor.visitIfndef_directive(self)
            else:
                return visitor.visitChildren(self)




    def ifndef_directive(self):

        localctx = VerilogPreprocessorParser.Ifndef_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_ifndef_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 144
            self.match(VerilogPreprocessorParser.DIRECTIVE_IFNDEF)
            self.state = 145
            self.text_macro_identifier()
            self.state = 150
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 148
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [VerilogPreprocessorParser.SOURCE_TEXT]:
                        self.state = 146
                        self.match(VerilogPreprocessorParser.SOURCE_TEXT)
                        pass
                    elif token in [VerilogPreprocessorParser.GRAVE_ACCENT]:
                        self.state = 147
                        self.compiler_directive()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 152
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

            self.state = 156
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 153
                    self.elsif_directive() 
                self.state = 158
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

            self.state = 160
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.state = 159
                self.else_directive()


            self.state = 162
            self.endif_directive()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Elsif_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_ELSIF(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_ELSIF, 0)

        def text_macro_identifier(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Text_macro_identifierContext,0)


        def SOURCE_TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(VerilogPreprocessorParser.SOURCE_TEXT)
            else:
                return self.getToken(VerilogPreprocessorParser.SOURCE_TEXT, i)

        def compiler_directive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreprocessorParser.Compiler_directiveContext)
            else:
                return self.getTypedRuleContext(VerilogPreprocessorParser.Compiler_directiveContext,i)


        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_elsif_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElsif_directive" ):
                listener.enterElsif_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElsif_directive" ):
                listener.exitElsif_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElsif_directive" ):
                return visitor.visitElsif_directive(self)
            else:
                return visitor.visitChildren(self)




    def elsif_directive(self):

        localctx = VerilogPreprocessorParser.Elsif_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_elsif_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 164
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 165
            self.match(VerilogPreprocessorParser.DIRECTIVE_ELSIF)
            self.state = 166
            self.text_macro_identifier()
            self.state = 171
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,13,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 169
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [VerilogPreprocessorParser.SOURCE_TEXT]:
                        self.state = 167
                        self.match(VerilogPreprocessorParser.SOURCE_TEXT)
                        pass
                    elif token in [VerilogPreprocessorParser.GRAVE_ACCENT]:
                        self.state = 168
                        self.compiler_directive()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 173
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,13,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Else_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_ELSE(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_ELSE, 0)

        def SOURCE_TEXT(self, i:int=None):
            if i is None:
                return self.getTokens(VerilogPreprocessorParser.SOURCE_TEXT)
            else:
                return self.getToken(VerilogPreprocessorParser.SOURCE_TEXT, i)

        def compiler_directive(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreprocessorParser.Compiler_directiveContext)
            else:
                return self.getTypedRuleContext(VerilogPreprocessorParser.Compiler_directiveContext,i)


        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_else_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterElse_directive" ):
                listener.enterElse_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitElse_directive" ):
                listener.exitElse_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitElse_directive" ):
                return visitor.visitElse_directive(self)
            else:
                return visitor.visitChildren(self)




    def else_directive(self):

        localctx = VerilogPreprocessorParser.Else_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_else_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 175
            self.match(VerilogPreprocessorParser.DIRECTIVE_ELSE)
            self.state = 180
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,15,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 178
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [VerilogPreprocessorParser.SOURCE_TEXT]:
                        self.state = 176
                        self.match(VerilogPreprocessorParser.SOURCE_TEXT)
                        pass
                    elif token in [VerilogPreprocessorParser.GRAVE_ACCENT]:
                        self.state = 177
                        self.compiler_directive()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 182
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,15,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Endif_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_ENDIF(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_ENDIF, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_endif_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndif_directive" ):
                listener.enterEndif_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndif_directive" ):
                listener.exitEndif_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndif_directive" ):
                return visitor.visitEndif_directive(self)
            else:
                return visitor.visitChildren(self)




    def endif_directive(self):

        localctx = VerilogPreprocessorParser.Endif_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_endif_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 184
            self.match(VerilogPreprocessorParser.DIRECTIVE_ENDIF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Include_compiler_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_INCLUDE(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_INCLUDE, 0)

        def filename(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.FilenameContext,0)


        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_include_compiler_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInclude_compiler_directive" ):
                listener.enterInclude_compiler_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInclude_compiler_directive" ):
                listener.exitInclude_compiler_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInclude_compiler_directive" ):
                return visitor.visitInclude_compiler_directive(self)
            else:
                return visitor.visitChildren(self)




    def include_compiler_directive(self):

        localctx = VerilogPreprocessorParser.Include_compiler_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_include_compiler_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 186
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 187
            self.match(VerilogPreprocessorParser.DIRECTIVE_INCLUDE)
            self.state = 188
            self.filename()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilenameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIRECTIVE_STRING(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_STRING, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_filename

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilename" ):
                listener.enterFilename(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilename" ):
                listener.exitFilename(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilename" ):
                return visitor.visitFilename(self)
            else:
                return visitor.visitChildren(self)




    def filename(self):

        localctx = VerilogPreprocessorParser.FilenameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_filename)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            self.match(VerilogPreprocessorParser.DIRECTIVE_STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Resetall_compiler_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_RESETALL(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_RESETALL, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_resetall_compiler_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterResetall_compiler_directive" ):
                listener.enterResetall_compiler_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitResetall_compiler_directive" ):
                listener.exitResetall_compiler_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResetall_compiler_directive" ):
                return visitor.visitResetall_compiler_directive(self)
            else:
                return visitor.visitChildren(self)




    def resetall_compiler_directive(self):

        localctx = VerilogPreprocessorParser.Resetall_compiler_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_resetall_compiler_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 192
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 193
            self.match(VerilogPreprocessorParser.DIRECTIVE_RESETALL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Line_compiler_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_LINE(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_LINE, 0)

        def line_number(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Line_numberContext,0)


        def filename(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.FilenameContext,0)


        def line_level(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Line_levelContext,0)


        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_line_compiler_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLine_compiler_directive" ):
                listener.enterLine_compiler_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLine_compiler_directive" ):
                listener.exitLine_compiler_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLine_compiler_directive" ):
                return visitor.visitLine_compiler_directive(self)
            else:
                return visitor.visitChildren(self)




    def line_compiler_directive(self):

        localctx = VerilogPreprocessorParser.Line_compiler_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_line_compiler_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 196
            self.match(VerilogPreprocessorParser.DIRECTIVE_LINE)
            self.state = 197
            self.line_number()
            self.state = 198
            self.filename()
            self.state = 199
            self.line_level()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Line_numberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIRECTIVE_NUMBER(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_NUMBER, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_line_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLine_number" ):
                listener.enterLine_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLine_number" ):
                listener.exitLine_number(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLine_number" ):
                return visitor.visitLine_number(self)
            else:
                return visitor.visitChildren(self)




    def line_number(self):

        localctx = VerilogPreprocessorParser.Line_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_line_number)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            self.match(VerilogPreprocessorParser.DIRECTIVE_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Line_levelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIRECTIVE_NUMBER(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_NUMBER, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_line_level

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLine_level" ):
                listener.enterLine_level(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLine_level" ):
                listener.exitLine_level(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLine_level" ):
                return visitor.visitLine_level(self)
            else:
                return visitor.visitChildren(self)




    def line_level(self):

        localctx = VerilogPreprocessorParser.Line_levelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_line_level)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            self.match(VerilogPreprocessorParser.DIRECTIVE_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Timescale_compiler_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_TIMESCALE(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_TIMESCALE, 0)

        def time_literal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VerilogPreprocessorParser.Time_literalContext)
            else:
                return self.getTypedRuleContext(VerilogPreprocessorParser.Time_literalContext,i)


        def DIRECTIVE_SLASH(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_SLASH, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_timescale_compiler_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimescale_compiler_directive" ):
                listener.enterTimescale_compiler_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimescale_compiler_directive" ):
                listener.exitTimescale_compiler_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimescale_compiler_directive" ):
                return visitor.visitTimescale_compiler_directive(self)
            else:
                return visitor.visitChildren(self)




    def timescale_compiler_directive(self):

        localctx = VerilogPreprocessorParser.Timescale_compiler_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_timescale_compiler_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 206
            self.match(VerilogPreprocessorParser.DIRECTIVE_TIMESCALE)
            self.state = 207
            self.time_literal()
            self.state = 208
            self.match(VerilogPreprocessorParser.DIRECTIVE_SLASH)
            self.state = 209
            self.time_literal()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Time_literalContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def time_number(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Time_numberContext,0)


        def time_unit(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Time_unitContext,0)


        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_time_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_literal" ):
                listener.enterTime_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_literal" ):
                listener.exitTime_literal(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime_literal" ):
                return visitor.visitTime_literal(self)
            else:
                return visitor.visitChildren(self)




    def time_literal(self):

        localctx = VerilogPreprocessorParser.Time_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_time_literal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.time_number()
            self.state = 212
            self.time_unit()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Time_numberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIRECTIVE_NUMBER(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_NUMBER, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_time_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_number" ):
                listener.enterTime_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_number" ):
                listener.exitTime_number(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime_number" ):
                return visitor.visitTime_number(self)
            else:
                return visitor.visitChildren(self)




    def time_number(self):

        localctx = VerilogPreprocessorParser.Time_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_time_number)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 214
            self.match(VerilogPreprocessorParser.DIRECTIVE_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Time_unitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIME_UNIT(self):
            return self.getToken(VerilogPreprocessorParser.TIME_UNIT, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_time_unit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_unit" ):
                listener.enterTime_unit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_unit" ):
                listener.exitTime_unit(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTime_unit" ):
                return visitor.visitTime_unit(self)
            else:
                return visitor.visitChildren(self)




    def time_unit(self):

        localctx = VerilogPreprocessorParser.Time_unitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_time_unit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 216
            self.match(VerilogPreprocessorParser.TIME_UNIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unconnected_drive_compiler_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_UNCONNECTED_DRIVE(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_UNCONNECTED_DRIVE, 0)

        def unconnected_drive_value(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Unconnected_drive_valueContext,0)


        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_unconnected_drive_compiler_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnconnected_drive_compiler_directive" ):
                listener.enterUnconnected_drive_compiler_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnconnected_drive_compiler_directive" ):
                listener.exitUnconnected_drive_compiler_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnconnected_drive_compiler_directive" ):
                return visitor.visitUnconnected_drive_compiler_directive(self)
            else:
                return visitor.visitChildren(self)




    def unconnected_drive_compiler_directive(self):

        localctx = VerilogPreprocessorParser.Unconnected_drive_compiler_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_unconnected_drive_compiler_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 218
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 219
            self.match(VerilogPreprocessorParser.DIRECTIVE_UNCONNECTED_DRIVE)
            self.state = 220
            self.unconnected_drive_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unconnected_drive_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNCONNECTED_DRIVE_VALUE(self):
            return self.getToken(VerilogPreprocessorParser.UNCONNECTED_DRIVE_VALUE, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_unconnected_drive_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnconnected_drive_value" ):
                listener.enterUnconnected_drive_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnconnected_drive_value" ):
                listener.exitUnconnected_drive_value(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnconnected_drive_value" ):
                return visitor.visitUnconnected_drive_value(self)
            else:
                return visitor.visitChildren(self)




    def unconnected_drive_value(self):

        localctx = VerilogPreprocessorParser.Unconnected_drive_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_unconnected_drive_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 222
            self.match(VerilogPreprocessorParser.UNCONNECTED_DRIVE_VALUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Nounconnected_drive_compiler_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_NOUNCONNECTED_DRIVE(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_NOUNCONNECTED_DRIVE, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_nounconnected_drive_compiler_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNounconnected_drive_compiler_directive" ):
                listener.enterNounconnected_drive_compiler_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNounconnected_drive_compiler_directive" ):
                listener.exitNounconnected_drive_compiler_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNounconnected_drive_compiler_directive" ):
                return visitor.visitNounconnected_drive_compiler_directive(self)
            else:
                return visitor.visitChildren(self)




    def nounconnected_drive_compiler_directive(self):

        localctx = VerilogPreprocessorParser.Nounconnected_drive_compiler_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_nounconnected_drive_compiler_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 224
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 225
            self.match(VerilogPreprocessorParser.DIRECTIVE_NOUNCONNECTED_DRIVE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Keywords_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_BEGIN_KEYWORDS(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_BEGIN_KEYWORDS, 0)

        def version_specifier(self):
            return self.getTypedRuleContext(VerilogPreprocessorParser.Version_specifierContext,0)


        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_keywords_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKeywords_directive" ):
                listener.enterKeywords_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKeywords_directive" ):
                listener.exitKeywords_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeywords_directive" ):
                return visitor.visitKeywords_directive(self)
            else:
                return visitor.visitChildren(self)




    def keywords_directive(self):

        localctx = VerilogPreprocessorParser.Keywords_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_keywords_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 227
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 228
            self.match(VerilogPreprocessorParser.DIRECTIVE_BEGIN_KEYWORDS)
            self.state = 229
            self.version_specifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Version_specifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIRECTIVE_STRING(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_STRING, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_version_specifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVersion_specifier" ):
                listener.enterVersion_specifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVersion_specifier" ):
                listener.exitVersion_specifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVersion_specifier" ):
                return visitor.visitVersion_specifier(self)
            else:
                return visitor.visitChildren(self)




    def version_specifier(self):

        localctx = VerilogPreprocessorParser.Version_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_version_specifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self.match(VerilogPreprocessorParser.DIRECTIVE_STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Endkeywords_directiveContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRAVE_ACCENT(self):
            return self.getToken(VerilogPreprocessorParser.GRAVE_ACCENT, 0)

        def DIRECTIVE_END_KEYWORDS(self):
            return self.getToken(VerilogPreprocessorParser.DIRECTIVE_END_KEYWORDS, 0)

        def getRuleIndex(self):
            return VerilogPreprocessorParser.RULE_endkeywords_directive

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEndkeywords_directive" ):
                listener.enterEndkeywords_directive(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEndkeywords_directive" ):
                listener.exitEndkeywords_directive(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEndkeywords_directive" ):
                return visitor.visitEndkeywords_directive(self)
            else:
                return visitor.visitChildren(self)




    def endkeywords_directive(self):

        localctx = VerilogPreprocessorParser.Endkeywords_directiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_endkeywords_directive)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            self.match(VerilogPreprocessorParser.GRAVE_ACCENT)
            self.state = 234
            self.match(VerilogPreprocessorParser.DIRECTIVE_END_KEYWORDS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





