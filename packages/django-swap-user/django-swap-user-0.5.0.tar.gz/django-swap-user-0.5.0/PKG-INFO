Metadata-Version: 2.1
Name: django-swap-user
Version: 0.5.0
Summary: (Beta) Simple and flexible way to swap default Django User
Home-page: http://github.com/artinnok/django-swap-user
License: MIT
Keywords: django,swap,user,custom,user,auth,model,email,username,phone,mixins,authentication
Author: Artem Innokentiev
Author-email: artinnok@protonmail.com
Maintainer: Artem Innokentiev
Maintainer-email: artinnok@protonmail.com
Requires-Python: >=3.6,<4.0
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.6
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Requires-Dist: django (>=2.2)
Requires-Dist: django-phonenumber-field[phonenumbers] (>=5.2.0,<6.0.0)
Project-URL: Repository, http://github.com/artinnok/django-swap-user
Description-Content-Type: text/markdown

# Django-Swap-User (Beta)

## About
If you are tired from copying one custom user model from one project to another ones - use this package.
This will do all for you. 


## Installation
```
pip install django-swap-user
```

## Basic usage
1. Choose one of models and settings from table:

| Application name | Username field | Description                                                           | `INSTALLED_APPS`                                 | `AUTH_USER_MODEL`               |
|------------------|----------------|-----------------------------------------------------------------------|------------------------------------------------|-----------------------------------|
| `to_email`       | `email`        | User with `email` username                                            | ```"swap_user", "swap_user.to_email",```       | `"to_email.EmailUser"`            |
| `to_named_email` | `email`        | User with `email` username, `first_name` and `last_name` extra fields | ```"swap_user", "swap_user.to_named_email",``` | `"to_named_email.NamedEmailUser"` |
| `to_phone`       | `phone`        | User with `phone` username                                            | ```"swap_user", "swap_user.to_phone",```       | `"to_phone.PhoneUser"`            |
| `to_phone_otp`   | `phone`        | User with `phone` username  and OTP authentication                    | ```"swap_user", "swap_user.to_phone_otp",```   | `"to_phone.PhoneOTPUser"`         |

2. Add corresponding app to `INSTALLED_APPS`:
```python
INSTALLED_APPS = [
    ...
    "swap_user",
    "swap_user.to_named_email",
    ...
]
```
3. Change `AUTH_USER_MODEL` to corresponding:
```python
AUTH_USER_MODEL = "to_named_email.NamedEmailUser"
```


## Architecture
Application `swap_user` split into 3 apps:
  - `to_email` - provides user with `email` username field
  - `to_named_email` - provides user with `email` username field and with `first_name`, `last_name` extra fields
  - `to_phone` - provides user with `phone` username field
  - `to_phone_otp` - provides user with `phone` username field and with OTP authentication
  
  
## Why?
Because if we leave them in one app, they all will create migrations and tables - such approach leads us to redundant tables.
They will be treated as 3 custom models within the same app, which causes perplexing and cognitive burden.

With such approach (when there is a common app which contains internal apps) - the user 
choose and connect only the specific user model which suits best for concrete business-logic. 

I have found such approach at Django REST Framework `authtoken` application and decide to use it - reference is [here](https://github.com/encode/django-rest-framework/tree/master/rest_framework/authtoken).

